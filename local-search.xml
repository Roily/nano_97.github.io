<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pinia基本使用(四)の仓库互调用&amp;重置仓库</title>
    <link href="/2022/04/30/Vue/pinia4/"/>
    <url>/2022/04/30/Vue/pinia4/</url>
    
    <content type="html"><![CDATA[<h2 id="仓库互调用"><a href="#仓库互调用" class="headerlink" title="仓库互调用"></a>仓库互调用</h2><ol><li>理解: 在仓库中引入另一个仓库实例化后进行调用<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">index.tsimport &#123;defineStore,storeToRefs&#125; from &#39;pinia&#39;&#x2F;&#x2F; 引入另一个仓库import &#123;effStore&#125; from &#39;.&#x2F;eff&#39;type numbers&#x3D;&#123;  count: any&#125;export const mainStore&#x3D;defineStore(&#39;main&#39;,&#123;  state: () &#x3D;&gt; &#123;    return &lt;numbers&gt;&#123;      count: 0    &#125;  &#125;,  getters: &#123;&#125;,  actions: &#123;    changeV(v: number) &#123;        &#x2F;&#x2F; 在这里对引入的仓库进行实例化,可以直接相互调用      const &#123;num&#125;&#x3D;effStore()      this.count&#x3D;this.count+num    &#125;  &#125;&#125;)eff.tsimport &#123;defineStore&#125; from &#39;pinia&#39;type v&#x3D;&#123;  num: Number&#125;export const effStore&#x3D;defineStore(&#39;eff&#39;,&#123;  state: () &#x3D;&gt; &#123;    return &lt;v&gt;&#123;      num: 5    &#125;  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="仓库的重置"><a href="#仓库的重置" class="headerlink" title="仓库的重置"></a>仓库的重置</h2><p>  定义: 使用仓库实例上的$reset方法,将仓库数据全部初始化<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;import &#123; mainStore &#125; from &#39;.&#x2F;store&#x2F;index&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39;const store &#x3D; mainStore()const &#123; count, countDouble &#125; &#x3D; storeToRefs(store)const foo &#x3D; () &#x3D;&gt; &#123;  store.changeV(3)&#125;const reset &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 仓库实例上调用重置方法  store.$reset()&#125;&lt;&#x2F;script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;h1&gt;  &lt;h2&gt;&#123;&#123; countDouble &#125;&#125;&lt;&#x2F;h2&gt;  &lt;button @click&#x3D;&quot;foo&quot;&gt;点击&lt;&#x2F;button&gt;  &lt;button @click&#x3D;&quot;reset&quot;&gt;重置&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia基本使用(三)の值得修改</title>
    <link href="/2022/04/30/Vue/pinia3/"/>
    <url>/2022/04/30/Vue/pinia3/</url>
    
    <content type="html"><![CDATA[<h2 id="值的修改"><a href="#值的修改" class="headerlink" title="值的修改"></a>值的修改</h2><ol><li><p>直接修改(不推荐)<br>定义: 可以在setup里直接对store里的值进行修改</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;import &#123; mainStore &#125; from &#39;.&#x2F;store&#x2F;index&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39;const &#123; stateValue &#125; &#x3D; storeToRefs(mainStore())stateValue &#x3D; 20&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>$patch修改<br>定义: 当同时修改多个变量时,效率比直接修改高<br>用法: 对象写法 和 函数写法</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import &#123; mainStore &#125; from &#39;.&#x2F;store&#x2F;index&#39;import &#123; storeToRefs &#125; from &#39;pinia&#39;const store &#x3D; mainStore()&#x2F;* 对象写法 *&#x2F;store.$patch(&#123;  count:store.count++&#125;)&#x2F;* 函数写法 *&#x2F;store.$patch((state)&#x3D;&gt;&#123;  state.count++&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>actions<strong>[推荐]</strong><br>定义: 在store的actions中定义方法,同过this直接修改</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">state:()&#x3D;&gt;&#123;  return &#123; count:0 &#125;&#125;,actions:&#123;  changeV(param)&#123;    this.count &#x3D; this.count + param  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia基本使用(二)の值的获取</title>
    <link href="/2022/04/30/Vue/pinia2/"/>
    <url>/2022/04/30/Vue/pinia2/</url>
    
    <content type="html"><![CDATA[<h2 id="仓库获取值的方式"><a href="#仓库获取值的方式" class="headerlink" title="仓库获取值的方式"></a>仓库获取值的方式</h2><ol><li>通过仓库实例获取<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script lang&#x3D;&quot;ts&quot; setup&gt;  import &#123; mainStore &#125; from &#39;.&#x2F;sotre&#x2F;index&#39;  const store &#x3D; mainStore()  const change &#x3D; ()&#x3D;&gt;&#123; store.change(1) &#125;&lt;&#x2F;script&gt;&lt;template&gt;    &lt;h1&gt;&#123;&#123; store.count &#125;&#125;&lt;&#x2F;h1&gt;    &lt;button @click&#x3D;&quot;change&quot;&gt;改变&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>解构仓库实例获取</li></ol><p>  <strong>注意:</strong> 解构都会使数据失去响应式,所以可以通过vue本身提供的<code>toRefs</code>添加响应式或者pinia提供的<code>storeToRefs</code><br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script lang&#x3D;&quot;ts&quot; setup&gt;    import &#123; mainStore &#125; from &#39;.&#x2F;sotre&#x2F;index&#39;    &#x2F;* 推荐使用pinia提供的添加响应式方法 *&#x2F;    import &#123; storeToRefs &#125; from &#39;pinia&#39;    const store &#x3D; mainStore()    const &#123; count &#125; &#x3D; storeToRefs(store)    const change &#x3D; ()&#x3D;&gt;&#123; store.change(1) &#125;&lt;&#x2F;script&gt;&lt;template&gt;  &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;h1&gt;  &lt;button @click&#x3D;&quot;change&quot;&gt;改变&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p><blockquote><p><strong>值得注意:</strong> 在ts中,使用storeToRefs解构actions中的方法会提示找不到,所以如果是方法不推荐解构获取</p></blockquote><ol start="3"><li>map函数<br>定义: pinia提供了类似vuex中的map函数,返回一个值/方法的集合对象<br>用法:<br>   mapState(模块名称,数组/对象),mapGetters(),mapActions()<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script lang&#x3D;&quot;ts&quot; setup&gt;    import &#123; mainStore &#125; from &#39;.&#x2F;sotre&#x2F;index&#39;    &#x2F;* 推荐使用pinia提供的添加响应式方法 *&#x2F;    import &#123; mapState,mapActions, mapGetters &#125; from &#39;pinia&#39;    const &#123; count &#125; &#x3D; mapState(mainStore,[      &#39;count&#39;,&#39;value1&#39;, &#39;value2&#39;    ])    &#x2F;* 对象方法写法 mapState独有      可以对state的值进行加工     *&#x2F;    const stateAll &#x3D; mapState(mainStore, &#123;       count(state)&#123;        return state.count ** 2       &#125;    &#125;)    const store4 &#x3D; mapGetters(mainStore, [&#39;countDouble&#39;])    const dbCount &#x3D; store4.dbCount()    const &#123; changeV &#125; &#x3D; mapActions(mainStore, [&#39;changeV&#39;])    const foo &#x3D; ()&#x3D;&gt;&#123; changeV(3) &#125;&lt;&#x2F;script&gt;&lt;template&gt;  &#x2F;&#x2F; 返回的是函数需要执行一下才能返回真正的值  &lt;h1&gt;&#123;&#123; count() &#125;&#125;&lt;&#x2F;h1&gt;  &lt;button @click&#x3D;&quot;foo&quot;&gt;改变&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong>注意</strong>: 使用mapState和mapGetters获取指定值,返回的都是函数,需要调用获取真正的值<br><strong>注意</strong>: 解构不会失去响应式</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pinia基本使用(一)の简单使用</title>
    <link href="/2022/04/30/Vue/pinia/"/>
    <url>/2022/04/30/Vue/pinia/</url>
    
    <content type="html"><![CDATA[<h2 id="pinia的优点"><a href="#pinia的优点" class="headerlink" title="pinia的优点"></a>pinia的优点</h2><ol><li>支持vue2、vue3</li><li>抛弃了Mutations操作,只有state、getters和actions</li><li>不需要嵌套模块,符合vue3的Composition API</li><li>完整的TS支持</li><li>代码更加简洁</li><li>没有命名空间</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li><p>安装<br><code>npm install pinia || yarn add pinia</code></p></li><li><p>在main.ts中挂载pinia实例</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import &#123;createApp&#125; from &#39;vue&#39;&#x2F;&#x2F; 引入createPinia 构造方法import &#123;createPinia&#125; from &#39;pinia&#39;import App from &#39;.&#x2F;App.vue&#39;&#x2F;&#x2F; 调用createPinia方法创建pinia实例const pinia&#x3D;createPinia()const app&#x3D;createApp(App)&#x2F;&#x2F; 通过app.use挂载到全局app.use(pinia).mount(&#39;#app&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>创建仓库<br>(1) 通过pinia提供的defineStore函数创建<br>(2) defineStore接收两个参数(仓库名称,配置项)<br>(3) 创建实例后导出</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import &#123; defineStore &#125; from &#39;pinia&#39;&#x2F;**  基本格式:    state: 函数返回    getters: 与vuex一致    actions: 取消了上下文参数,通过this获取state和getters里的变量*&#x2F;export const mainStore &#x3D; defineStore( &#39;main&#39;,&#123;  state:( )&#x3D;&gt;&#123;    return&#123;      count: 0    &#125;  &#125;,  getters:&#123;    doubleCount(state)&#123;        return state.count*2    &#125;  &#125;,  actions:&#123;    changeCount( )&#123;        this.count +&#x3D;2    &#125;  &#125;&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>使用<br>定义:在vue组件或ts文件中引入导出的仓库实例</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;import &#123; mainStore &#125; from &#39;.&#x2F;store&#x2F;index&#39;const store &#x3D; mainStore()&lt;&#x2F;script&gt;&lt;template&gt;  &#x2F;* 这里不同于vuex,不需要通过.[属性名]去获取   *&#x2F;  &lt;h1&gt; &#123;&#123;store.count&#125;&#125; &lt;&#x2F;h1&gt;  &lt;h1&gt; &#123;&#123;store.doubleCount&#125;&#125; &lt;&#x2F;h1&gt;  &lt;button @click&#x3D;&quot;store.changeCount&quot;&gt;改变&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue3</tag>
      
      <tag>pinia</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件总线</title>
    <link href="/2022/04/14/JavaScript/jsBasic_53/"/>
    <url>/2022/04/14/JavaScript/jsBasic_53/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li><p>属于一种观察者模式,其中包括三个角色:<br>(1) 发布者 : 发出事件<br>(2) 订阅者 : 订阅事件,并且会进行响应<br>(3) 事件总线 : 无论是发布者还是订阅者都是通过事件总线作为中台的</p></li><li><p>代码</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class NanoEventBus &#123;  constructor() &#123;    this.eventBus &#x3D; &#123;&#125;  &#125;  on(eventName, eventCallback, thisArg) &#123;    let handler &#x3D; this.eventBus[eventName]    if (!handler) &#123;      handler &#x3D; []      this.eventBus[eventName] &#x3D; handler    &#125;    handler.push(&#123;      eventCallback,      thisArg    &#125;)  &#125;  off(eventName, eventCallback) &#123;    const handlers &#x3D; this.eventBus[eventName]    if (!handlers) return    const newHandlers &#x3D; [...handlers]    for (let i &#x3D; 0; i &lt; newHandlers.length; i++) &#123;      const handler &#x3D; newHandlers[i]      if (handler.eventCallback &#x3D;&#x3D;&#x3D; eventCallback) &#123;        const index &#x3D; handlers.indexOf(handler)        handlers.splice(index, 1)      &#125;    &#125;  &#125;  emit(eventName, ...playload) &#123;    const handler &#x3D; this.eventBus[eventName]    if (!handler) return    handler.forEach(item &#x3D;&gt; &#123;      if (item.thisArg) &#123;        item.eventCallback.apply(item.thisArg, playload)      &#125; else &#123;        item.eventCallback(...playload)      &#125;    &#125;)  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝</title>
    <link href="/2022/04/14/JavaScript/jsBasic_52/"/>
    <url>/2022/04/14/JavaScript/jsBasic_52/</url>
    
    <content type="html"><![CDATA[<ol><li>代码<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function isObject(value) &#123;  const valueType &#x3D; typeof value  return (value !&#x3D;&#x3D; null) &amp;&amp; (valueType &#x3D;&#x3D;&#x3D; &#39;object&#39; || valueType &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#125;function deepClone(param, map &#x3D; new WeakMap()) &#123;  &#x2F;&#x2F; 判断是否是一个Set类型  if (param instanceof Set) &#123;    return new Set([...param])  &#125;  &#x2F;&#x2F; 判断是否是一个Map类型  if (param instanceof Map) &#123;    return new Map([...param])  &#125;  &#x2F;&#x2F; 判断symbol  if (typeof param &#x3D;&#x3D;&#x3D; &#39;symbol&#39;) &#123;    return Symbol(param.description)  &#125;  &#x2F;&#x2F; 判断非函数和对象直接返回  if (!isObject(param) || typeof param &#x3D;&#x3D;&#x3D; &#39;function&#39;) return param  &#x2F;&#x2F; 判断是数组还是对象  &#x2F;&#x2F; 判断是否存储过newObj (解决循环引用)  if (map.has(param)) &#123;    return map.get(param)  &#125;  const newObj &#x3D; Array.prototype.isPrototypeOf(param) ? [] : &#123;&#125;  map.set(param, newObj)  for (let key in param) &#123;    newObj[key] &#x3D; deepClone(param[key], map)  &#125;  &#x2F;&#x2F; 对symbol的key做特殊处理  const symbolKeys &#x3D; Object.getOwnPropertySymbols(param)  for (const item of symbolKeys) &#123;    newObj[item] &#x3D; deepClone(param[item], map)  &#125;  return newObj&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖(debounce) &amp; 节流(throttle)</title>
    <link href="/2022/04/14/JavaScript/jsBasic_51/"/>
    <url>/2022/04/14/JavaScript/jsBasic_51/</url>
    
    <content type="html"><![CDATA[<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><ol><li>定义: 在规定的时间内如果事件被密集触发,则规定的时间重新计算并且规定的时间结束后只触发最后一次事件。</li><li>应用场景:<br>(1) 输入框中频繁的输入内容,搜索或者提交信息<br>(2) 频繁的点击按钮,触发某个时间<br>(3) 监听浏览器滚动事件,完成某些特定操作<br>(4) 用户缩放浏览器的resize事件</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function debounce(fn, delay, immediate &#x3D; false, resultCb) &#123;let timer &#x3D; null&#x2F;&#x2F; 定义是否执行过let isInvoke &#x3D; false&#x2F;&#x2F; 不能用箭头函数,否则this指向声明的作用域const _debounce &#x3D; function(...args) &#123;  if (immediate &amp;&amp; !isInvoke) &#123;    const res &#x3D; fn.apply(this, args)    if (resultCb) &#123;      resultCb(res)    &#125;    isInvoke &#x3D; true  &#125; else &#123;    if (timer) clearTimeout(timer)    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;      &#x2F;&#x2F; 绑定触发对象的this和事件参数      const res &#x3D; fn.apply(this, args)      if (resultCb) &#123;        &#x2F;&#x2F; 回调传递返回值        resultCb(res)      &#125;      timer &#x3D; null      &#x2F;&#x2F; 设置为false下次事件第一次输入仍然是立即执行      isInvoke &#x3D; false    &#125;, delay)  &#125;&#125;&#x2F;&#x2F; 取消功能 函数也是一个对象,可以挂载一个方法_debounce.cancel &#x3D; function() &#123;  if (timer) clearTimeout(timer)  timer &#x3D; null  isInvoke &#x3D; false&#125;return _debounce&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><ol><li>定义: 在规定的一段时间内密集触发事件,事件只会触发一次,并且这段时间只有完全结束后才会重置( 一般都是执行规定时间内第一次触发的事件 )</li><li>应用场景:<br>(1) 监听页面的滚动事件<br>(2) 鼠标移动事件<br>(3) 用户频繁点击按钮操作<br>(4) 游戏中的一些设计( 飞机大战发射子弹 )</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">    function throttle(fn, interval, options &#x3D; &#123;  leading: true,  trailing: false&#125;) &#123;  &#x2F;&#x2F; 上一次开始时间,默认为0  const &#123;    leading &#x3D; true,      trailing &#x3D; false  &#125; &#x3D; options  let lastTime &#x3D; 0  let timer &#x3D; null  const _throttle &#x3D; function(..args) &#123;    &#x2F;&#x2F; 每次触发时的当前时间    const nowTime &#x3D; new Date().getTime()    &#x2F;&#x2F; 如果是第一次进入并且不希望一开始就执行(leading &#x3D;&#x3D;&#x3D; false)    if (lastTime &#x3D;&#x3D;&#x3D; 0 &amp;&amp; leading &#x3D;&#x3D;&#x3D; false) &#123;      lastTime &#x3D; nowTime    &#125;    &#x2F;&#x2F; 计算剩余期间    const remainTime &#x3D; interval - (nowTime - lastTime)    if (remainTime &lt;&#x3D; 0) &#123;      &#x2F;&#x2F; 如果有真正执行的函数,则不需要触发同一期间内非第一次执行的函数      if (timer) &#123;        clearTimeout(timer)        timer &#x3D; null      &#125;      &#x2F;&#x2F; 如果剩余期间小于等于0执行事件函数      fn.apply(this, args)      &#x2F;&#x2F; 将本次当前时间设置为最后一次触发时间,进入下一个周期      lastTime &#x3D; nowTime      return    &#125;    &#x2F;&#x2F; 范围期间内非第一次输入的值是否执行    if (trailing &amp;&amp; !timer) &#123;      &#x2F;&#x2F; 只需要一个定时器      timer &#x3D; setTimeout(() &#x3D;&gt; &#123;        timer &#x3D; null        lastTime &#x3D; !leading ? 0 : new Date().getTime()        fn.apply(this, args)      &#125;, remainTime)    &#125;  &#125;  _throttle.cancel &#x3D; function() &#123;    if (timer) &#123;      clearTimeout(timer)      timer &#x3D; null      lastTime &#x3D; 0    &#125;  &#125;  return _throttle&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="/2022/04/14/JavaScript/jsBasic_50/"/>
    <url>/2022/04/14/JavaScript/jsBasic_50/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ol><li>定义: 提供了一系列的模型和对象,让我们可以方便的来操作Web页面。</li></ol><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><ol><li><p>定义: 在web当中,事件在浏览器窗口中被处罚,并且通过绑定到某些元素上或者浏览器窗口本身,那么我们就可以给这些元素或者window窗口来绑定事件的处理程序,来对事件进行监听</p></li><li><p>方式:<br>(1) 在script中直接监听<br>(2) 通过元素的on来监听事件</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;div onclick&#x3D;&quot; console.log(&#39;被点击了&#39;) &quot; id&#x3D;&quot;div1&quot; &gt; 点击 &lt;&#x2F;div&gt;    &lt;div onclick&#x3D;&quot; onClick() &quot; &gt; 点击 &lt;&#x2F;div&gt;    &lt;script&gt;  function onClick( )&#123; console.log( &#39;被点击了&#39; ) &#125;  const div1 &#x3D; document.querySelect(&#39; #div1 &#39;)  div1.onclick &#x3D; onClick&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 这两种方式一次只能监听一个事件,后一个会覆盖前一个</p></blockquote><p> (3) 通过EvnetTarget中的addEventListener来监听 </p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;div id&#x3D;&quot;div1&quot;&gt; 点击 &lt;&#x2F;div&gt;    &lt;script&gt;  function onClick( )&#123; console.log( &#39;被点击了&#39; ) &#125;  const div1 &#x3D; document.querySelect(&#39; #div1 &#39;)  div1.addEventListener( &#39;click&#39;, onClick ,false)&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>备注: 可以监听多个相同事件    </p></blockquote></li></ol><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><ol><li><p>定义: 事件冒泡和事件捕获</p></li><li><p>事件冒泡<br>(1) 定义: 从内部元素到外部元素</p></li><li><p>事件捕获<br> (1) 定义: 从外部元素到内部元素</p></li></ol><blockquote><p>注意: 先捕获再冒泡</p></blockquote><h2 id="事件对象-event"><a href="#事件对象-event" class="headerlink" title="事件对象(event)"></a>事件对象(event)</h2><ol><li><p>定义:获取触发事件的对象</p></li><li><p>event.target 和event.currentTarget 区别:<br> (1) event.target 指向发生事件时操作的元素<br> (2) event.currentTarget 一直指向绑定发生事件的元素</p></li><li><p>常见方法<br> (1) 阻止默认行为</p><div class="code-wrapper"><pre><code> i. event.preventDefault()</code></pre></div><p> (2) 阻止事件传递( 捕获&amp;冒泡 )</p><div class="code-wrapper"><pre><code> i. event.stopPropagation()</code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM</title>
    <link href="/2022/04/14/JavaScript/jsBasic_49/"/>
    <url>/2022/04/14/JavaScript/jsBasic_49/</url>
    
    <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ol><li>定义: 浏览器模型对象,是js脚本与浏览器窗口的桥梁。</li><li>对象模型：<br>(1) window ： 包括全局属性、方法，控制浏览器窗口相关的属性、方法<br>(2) location：浏览器连接到对象的位置（URL）<br>(3) history：浏览器的历史<br>(4) document：当前窗口操作文档的对象</li></ol><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><ol><li><p>全局对象<br>在node是Global, 在浏览器里就是window</p></li><li><p>浏览器窗口对象(BOM)<br>(1) 作为浏览器窗口时,提供了对浏览器操作的相关的API(继承自Event Target)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">window.onhashChange 监听地址栏哈希地址的改变&#x2F;* 继承自Event Target ,所以有 addEventListener()&#x2F;removeEventListener()&#x2F;window.dispatchEvent() *&#x2F;&#x2F;* 派发事件 *&#x2F;window.dispatchEvent( new Event(&#39;自定义事件对象&#39;) )addEventListener( &#39;自定义事件对象&#39;,()&#x3D;&gt;&#123;&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><ol><li>定义: 获取URL信息</li></ol><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><ol><li>定义:访问会话历史记录</li><li>属性:<br>(1) length: 会话中记录的条数<br>(2) state: 当前保留的状态值</li><li>常用方法 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">back(): 返回上一页,等价于history.go(-1)forward(): 前进下一页,等价于history.go(1)go(): 加载历史中的某一页pushState( &#123; name:  &#39;xxx&#39; &#125;, &#39;&#39;,  &#39;&#x2F;path&#39;( 路径 )  ): 打开一个指定的地址,不刷新网页replaceState( ):打开一个新地址,并且使用replace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie</title>
    <link href="/2022/04/14/JavaScript/jsBasic_48/"/>
    <url>/2022/04/14/JavaScript/jsBasic_48/</url>
    
    <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol><li>定义: 某些网站为了辨别用户身份而存储在用户本地终端上的数据,类型为小型文本文件。</li><li>场景: 浏览器会在特定的情况下携带上cookie来发送请求,我们可以通过cookie来获取一些信息。</li><li>分类:<br>(1) 内存cookie<br>   i. 定义: 存储在浏览器,由浏览器保存,浏览器关闭就会清除<br>(2) 硬盘cookie<br>   i. 定义: 存储在硬盘中,有过期时间,时间到期清除或者用户手动清除<br>(3) Q:如何判断是内存cookie还是硬盘cookie?<br>   A: cookie设置了过期时间,且过期时间不为0或者负数,那么就是硬盘cookie</li></ol><blockquote><p>备注: 主要由服务器端生成并设置在客户端(并不是我们手动设置),客户端也主动可以设置,比较少。<br>通过响应头(response header)中的set-cookie自动设置到客户端<br>设置后同一服务器的请求会自动在请求头 (request header)中携带cookie</p></blockquote><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ol><li><p>domain<br>(1) 定义: 指定哪些主机可以接收cookie<br>(2) 默认值: origin,不包括子域名</p></li><li><p>path<br>(1) 定义: 指定主机下的那些路径可以接收cookie<br>(2) 使用: 如果设置 /docs, 那么 /docs/a , /docs/b 都可以接收</p></li><li><p>max-age<br>(1) 定义:设置过期时间</p></li></ol><h2 id="客户端-JS-操作cookie"><a href="#客户端-JS-操作cookie" class="headerlink" title="客户端(JS)操作cookie"></a>客户端(JS)操作cookie</h2><ol><li>document.cookie<br>使用: 不能获取服务器设置的cookie,可以设置或者获取js设置的cookie</li></ol><h2 id="cookie缺点"><a href="#cookie缺点" class="headerlink" title="cookie缺点"></a>cookie缺点</h2><ol><li>浪费客户流量,每次相同域名下的请求都会自动携带cookie</li><li>cookie明文传输Headers,存在一定安全风险</li><li>大小限制为4KB</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器存储方案</title>
    <link href="/2022/04/14/JavaScript/jsBasic_47/"/>
    <url>/2022/04/14/JavaScript/jsBasic_47/</url>
    
    <content type="html"><![CDATA[<h2 id="localStorage-amp-sessionStorage"><a href="#localStorage-amp-sessionStorage" class="headerlink" title="localStorage &amp; sessionStorage"></a>localStorage &amp; sessionStorage</h2><ol><li><p>localStorage:<br>(1) 定义: 本地存储,提供的是一种永久性的存储方法,在关闭掉网页重新打开时,存储的内容依然保留</p></li><li><p>sessionStorage:<br>(1) 定义: 会话存储,提供的是本次会话的存储,在关闭掉会话时(浏览器本身或者浏览器标签页),存储的内容会被清除</p></li></ol><blockquote><p>备注: 同一域名下localStorage可以共享,同一标签栏下sessionStorage可以共享,Storage的大小只有5MB</p></blockquote><h2 id="IndexdDB"><a href="#IndexdDB" class="headerlink" title="IndexdDB"></a>IndexdDB</h2><ol><li>定义: 是一种底层的API,用于在客户端存储大量的结构化数据。它是一种事务型数据库系统,是一种基于JS面向对象数据库,有点类似于NoSQL(非关系型数据库)。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>html5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON &amp; JSON序列化 &amp; JSON解析</title>
    <link href="/2022/04/14/JavaScript/jsBasic_46/"/>
    <url>/2022/04/14/JavaScript/jsBasic_46/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON?"></a>什么是JSON?</h2><ol><li>定义: 是一种非常重要的数据格式,不是编程语言,而是一种可以在服务器和客户端之间传输的数据格式。</li></ol><h2 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h2><ol><li>JSON.stringify( )</li><li>定义: 将值转为JSON字符串</li><li>参数: target, foramt, space<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">format: 用来指定数据序列化的数据或者修改数据内容&#x2F;* 指定数据序列化  这里需要传递一个指定内容的数组*&#x2F;let obj &#x3D; &#123;  name: &#39;nano&#39;,  age:18,  height:180&#125;let jsonObj &#x3D; JSON.stringify( obj, [ &#39;name&#39;, &#39;age&#39; ] )console.log( jsonObj )  --&gt; &#123;&quot;name&quot;:&quot; nano&quot;,&quot;age&quot;:18&#125;&#x2F;* 修改数据内容 这里需要传递一个回调函数 回调参数接收两个参数 key,value*&#x2F;let obj &#x3D; &#123;  name: &#39;nano&#39;,  age:18,  height:180&#125;let jsonObj &#x3D; JSON.stringify( obj,   (key, value)&#x3D;&gt;&#123;     if(key &#x3D;&#x3D;&#x3D; &#39;age&#39;)&#123;       return value+&#x3D;1     &#125;else&#123; return value &#125;   &#125; )console.log( jsonObj ) --&gt; &#123;&quot;name&quot;:&quot;nano&quot;,&quot;age&quot;:19,&quot;height&quot;:180&#125; &#x2F;*  space: 用来进行格式化空格 *&#x2F;let obj &#x3D; &#123;  name: &#39;nano&#39;,  age:18,  height:180&#125;let jsonObj &#x3D; JSON.stringify( obj, null, 2 )console.log( jsonObj )--&gt; &#123;&quot;name&quot;: &quot;nano&quot;,&quot;age&quot;: 18,&quot;height&quot;: 180&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 实际调用了对象的toJSON( )方法</p></blockquote></li></ol><h2 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h2><ol><li>JSON.parse( )</li><li>定义: 将JSON字符串进行解析</li><li>参数: target , cb<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* cb: 转变解析参数的函数,接收两个参数(key,value) *&#x2F;  let obj &#x3D; &#123; name:&#39;nano&#39;, age:18 &#125;let jsonObj &#x3D; JSON.stringify( obj )let parseObj &#x3D; JSON.parse( jsonObj,   ( key, value )&#x3D;&gt;&#123;  if(key &#x3D;&#x3D;&#x3D; &#39;age&#39;)&#123; return --value &#125;else&#123; return value &#125;   &#125; )console.log( parseObj ) --&gt; &#123;name: &#39;nano&#39;, age: 17&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意:target参数只接受JSON字符串</p></blockquote></li></ol><h2 id="深拷贝-乞丐版"><a href="#深拷贝-乞丐版" class="headerlink" title="深拷贝(乞丐版)"></a>深拷贝(乞丐版)</h2><ol><li>JSON.parse( JSON.stringify() )<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123; name: &#39;nano&#39;, child:&#123; name:&#39;roily&#39; &#125;, foo()&#123;&#125;, height:null, gf:undefined&#125;let deepObj &#x3D; JSON.parse(JSON.stringify( obj ))console.log( deepObj )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 不会对方法和undefined的值,Symbol进行拷贝处理,深拷贝的值里面是不会出现的<br>注意: 不支持循环引用,拷贝会报错</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包管理工具和命令介绍</title>
    <link href="/2022/04/14/JavaScript/jsBasic_45/"/>
    <url>/2022/04/14/JavaScript/jsBasic_45/</url>
    
    <content type="html"><![CDATA[<h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><ol><li><p>npm ( Node Package Manager )<br>(1) 定义: Node包管理器,但是目前已经不限于Node,包括前端的其它工程<br>(2) 安装: 下载Node环境之后自动安装对应版本<br>(3) 上传/下载: 都是在registry这个仓库进行上传下载的<br>(4) 初始化项目: <code>npm init</code> / <code>npm init -y</code><br>(5) 版本号: X.Y.Z<br>   i. X 大版本更新,可能会有多个不兼容  Y 小版本更新,向下兼容 Z 修复版本<br>  ii. ^符号: 表示X版本保持不变,Y.Z 永远最新<br> iii. ~符号: 表示X和Y版本保持不变,Z永远安装最新</p></li><li><p>npm install 原理<br><img src="/img/JS/npm.png" alt="npm install 原理" title="npm install 原理 from coderWhy"></p></li></ol><blockquote><p>注意:  npm 安装的依赖默认安装进dependencies 生产依赖,如果需要安装进入devDependencies开发依赖则后面跟-D,cnpm安装的依赖不执行该下载逻辑<br>注意: 如果有lock文件会优先按照lock的版本安装,如果没有则是下载最新的版本;如果是指定版本安装,那么在安装后,lock文件检测版本不一致会自动更新为指定的版本    </p></blockquote><ol start="2"><li><p>yarn<br>(1) 定义:为了弥补早起npm的缺陷<br>(2) 安装: npm install -g yarn</p><blockquote><p>注意:一个项目中最好不要与npm混用</p></blockquote></li><li><p>npx<br>(1) 定义: 查找指定模块版本</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">当全局webpack版本  5.0.0当前项目webpack版本 3.6.1npx webpack --version  --&gt; 3.6.1如果是npm webpack --version,默认读取全局的版本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>npm</tag>
      
      <tag>yarn</tag>
      
      <tag>npx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES Module解析过程</title>
    <link href="/2022/04/14/JavaScript/jsBasic_44/"/>
    <url>/2022/04/14/JavaScript/jsBasic_44/</url>
    
    <content type="html"><![CDATA[<h2 id="ES-Module解析过程"><a href="#ES-Module解析过程" class="headerlink" title="ES Module解析过程"></a>ES Module解析过程</h2><ol><li><p>构建<br> 根据地址查找js文件,并且下载,将其静态分析成模块记录(Module Record)</p><blockquote><p>备注: 重复引用的文件不会重新下载,会有一个映射关系记录文件下载的状态,如果已经下载完成则不会再下载,进行一个缓存</p></blockquote></li><li><p>实例化<br> 对模块记录进行实例化,并且分配内存空间,只解析模块的导入和导出语句,把模块指向对应的内存地址( 此时导出和导入的值都是undefined,因为代码没有执行 )</p></li><li><p>运行<br> 运行代码,计算值,并且将值填充到内存地址中</p></li></ol><blockquote><p>注意: 导出的模块可以修改值,导入的模块不能修改</p></blockquote><h2 id="CommonJS和ES-Module的相互调用"><a href="#CommonJS和ES-Module的相互调用" class="headerlink" title="CommonJS和ES Module的相互调用"></a>CommonJS和ES Module的相互调用</h2><ol><li><p>定义: 需要分环境判断<br> (1) 浏览器环境</p><div class="code-wrapper"><pre><code> 结果: 不能 原因: 浏览器不支持CommonJS</code></pre></div><p> (2) node环境</p><div class="code-wrapper"><pre><code> 结果: 部分支持 原因: 部分node版本不支持ES Module</code></pre></div><p> (3) 基于Webpack的开发环境</p><div class="code-wrapper"><pre><code> 结果: 支持 原因: 会对CommonJS和ES Module做转换,进行相互支持</code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES Module</title>
    <link href="/2022/04/14/JavaScript/jsBasic_43/"/>
    <url>/2022/04/14/JavaScript/jsBasic_43/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>使用关键字import进行导入 export 进行导出,并默认开启严格模式</li></ol><h2 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h2><ol><li>export<br>(1) 定义: 声明语句导出<br>(2) 用法1: 后面可以直接跟声明语句</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">export const name &#x3D; &#39;nano&#39;export function add()&#123;&#125;export class Person &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>  (3) 用法2: 导出和声明分开<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const name &#x3D; &#39;nano&#39;const obj &#x3D; &#123; age:18 &#125;function add()&#123;&#125;export &#123;  name, obj, add&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p><blockquote><p><strong>注意:</strong> 这里并不是导出一个对象,而是导出一个变量集合</p></blockquote><p>  (4) 导出时起别名<br>    i. 定义: 使用<strong>as</strong>关键字<br>    <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const name &#x3D; &#39;nano&#39;const obj &#x3D; &#123; age:18 &#125;function add()&#123;&#125;export &#123;  name as otherName,   obj as otherObj,   add as otherAdd&#125;import &#123;otherName, otherObj, otherAdd &#125; from &#39;index.js&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p><blockquote><p>备注: 一般都是在导入时候起别名,导出时起别名用的较少</p></blockquote><h2 id="导入的方式"><a href="#导入的方式" class="headerlink" title="导入的方式"></a>导入的方式</h2><ol><li><p>普通导入<br>(1) 使用import导入</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import &#123; foo &#125; from &#39;.&#x2F;export.js&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>起别名导入<br>(1) 定义:防止导入的变量命名冲突<br>(2) 使用<strong>as</strong>关键字</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import &#123; foo as bar &#125; from &#39;.&#x2F;export.js&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li><p>将所有内容导入在一个标识符中<br>(1) 定义: 使用*和<strong>as</strong>关键字</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import * as allVariable from &#39;.&#x2F;index.js&#39;allVariable.foo()let obj &#x3D; allVariable.obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h2><ol><li>定义:导入后导出的语法糖<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">export &#123; foo &#125; from &#39;.&#x2F;index.js&#39;&#x2F;* 等价于↓↓↓ *&#x2F;import &#123; foo &#125; from &#39;.&#x2F;index.js&#39;export &#123; foo &#125;&#x2F;* 导入导出全部 *&#x2F;export * from &#39;.&#x2F;index.js&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><ol><li>默认导出方式1(常用)<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* export.js *&#x2F;const name &#x3D; &#39;nano&#39;const obj &#x3D; &#123; age:18 &#125;function add()&#123; console.log(&#39;add&#39;) &#125;export default add &#x2F;* import.js *&#x2F;import bar from &#39;.&#x2F;export.js&#39;bar() --&gt; &#39;add&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>默认导出方式2<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* export.js *&#x2F;const name &#x3D; &#39;nano&#39;const obj &#x3D; &#123; age:18 &#125;function add()&#123; console.log(&#39;add&#39;) &#125;export&#123;  name as nickName,  obj as nickObj,  add as default&#125;&#x2F;* import.js *&#x2F;import bar from &#39;.&#x2F;export.js&#39;bar() --&gt; &#39;add&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>与export区别<br>(1) 每一个js文件默认导出只能使用一次,并且后面不可以接声明语句<br>(2) 导入默认导出的变量时可以随意命名并且不需要 { } 包裹</li></ol><h2 id="导入同步异步的问题"><a href="#导入同步异步的问题" class="headerlink" title="导入同步异步的问题"></a>导入同步异步的问题</h2><ol><li>普通导入方式是同步的,会阻塞下面的代码执行,需要下载完导入的文件才可以往后执行 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 普通导入方式 *&#x2F;import &#123;a &#125; from &#39;index.js&#39;import foo from &#39;foo.js&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><strong>import<font color="red">函数导入是异步的</font></strong>,不会阻止后续代码执行<br>(1) 定义: 使用import()函数导入,返回一个promise,内部调用resolve,通过.then函数获取导入的变量 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">import(&#39;.&#x2F;index.js&#39;).then( res &#x3D;&gt; &#123; console.log(res) &#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模块化</title>
    <link href="/2022/04/13/JavaScript/jsBasic_42/"/>
    <url>/2022/04/13/JavaScript/jsBasic_42/</url>
    
    <content type="html"><![CDATA[<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol><li><p>定义: 将程序分成一个个小的模块,在这个模块中编写属于自己的逻辑代码,有自己的作用域,不会影响到其他的结构。整个模块可以将自己希望暴露的变量、函数、对象等导出给其它模块使用；也可以通过某种方式，导入另外模块中的变量、函数、对象等。</p></li><li><p>CommonJS [Node/WebPack]<br>(1) 在Node中每一个js文件都是一个单独的模块<br>(2) CommonJS规范的核心变量: exports、module.exports、require</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">exports.name &#x3D; &#39;nano&#39;module.exports &#x3D; &#123; name: &#39; nano&#39; &#125;const foo &#x3D; require(&#39;文件名&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>变量分析<br>(1) exports &amp; module.exports<br>定义: 负责对模块中的内容进行导出</p></li></ol><p>  (2) require<br>    定义: <strong><font color="red">是一个函数</font></strong>,可以帮助我们导入其它模块(自定义模块、系统模块、第三方库模块)中的内容<br>  i. module.exports &amp; require<br>    <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* a.js *&#x2F;let name &#x3D; &#39;nano&#39;let foo &#x3D; function()&#123;&#125;&#x2F;* 直接导出 *&#x2F;module.exports &#x3D; &#123;  name, foo&#125;&#x2F;* 导出集合对象  *&#x2F;let obj &#x3D; &#123; name,foo &#125;module.exports &#x3D; obj&#x2F;* b.js *&#x2F;const modeulA &#x3D; require(&#39;.&#x2F;a.js&#39;)console.log( moduleA ) --&gt; &#123; name: &#39;nano&#39;,foo:function()&#123;&#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p><blockquote><p><strong>注意: 最终导出都是以module.exports对象的形式被导出,所以一般都是用module.exports进行导出</strong></p></blockquote><p>ii. exports(不推荐)<br> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">a.jslet name  &#x3D; &#39;nano&#39;exports.name &#x3D; nameb.jsconst res &#x3D; reuiqre( &#39;.&#x2F;a.js&#39; )cosnole.log(  res ) --&gt; &#123; name: nano &#125;&#x2F;* 源码解析 *&#x2F;module.export &#x3D; &#123;&#125;&#x2F;&#x2F; 因为将module.export的地址赋值给exports,所以可以用exports导出,实际还是导出module.exports对象exports &#x3D; module.exportexports.name &#x3D; name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><ol><li>定义: require是一个函数,用来导入其他模块或者依赖包(核心模块)</li><li>查找规则:<br>(1) 如果是核心模块:<br>  直接引入后使用<br>(2) 如果是路径:<br>  没有写文件后缀,则按照 x.js -&gt; x.json -&gt; x.node<br>  写了文件后缀: 直接查找文件<br>(3) 如果既不是核心模块也不是路径:<br>  逐层向上查找每层的node_modules中是否有同名文件夹,找到之后自动寻找index.js文件作为引入</li></ol><h2 id="CommonJS的原理"><a href="#CommonJS的原理" class="headerlink" title="CommonJS的原理"></a>CommonJS的原理</h2><ol><li>声明的需要导出的对象、exports导出的对象、module.exports 导出的对象 与 require导入的对象都指向同一个地址</li></ol><h2 id="模块的加载过程-Common-js"><a href="#模块的加载过程-Common-js" class="headerlink" title="模块的加载过程(Common.js)"></a>模块的加载过程(Common.js)</h2><ol><li>模块在被<font color="red"><strong>第一次</strong></font>引入时,模块中的js代码<font color="red"><strong>会被运行一次</strong></font></li><li>模块被<font color="red"><strong>多次引入</strong></font>时,会被缓存,最终<font color="red"><strong>只加载(运行)一次</strong></font><br>(1) 每个模块对象都有一个属性loaded,false表示未加载,true表示已加载<br>(2) 重复引用的模块指针都是指向同一个地址,所以只会加载一次</li><li>循环引入的加载顺序(图结构):<br>(1) 按顺序执行require函数,如果里面还有require函数则继续执行 [深度优先搜索]<br>(2) 如果有不同模块引用了相同的模块,则执行优先引入的那个模块,后续因为缓存不执行引入 [广度优先搜索]</li></ol><h2 id="CommonJS缺点"><a href="#CommonJS缺点" class="headerlink" title="CommonJS缺点"></a>CommonJS缺点</h2><ol><li>加载模块是<font color="red"><strong>同步的</strong></font>,意味着只有将模块资源全部加载完成后才能执行下一步的代码，不适用于浏览器。</li><li>浏览器的js文件需要先从服务器下载再进行加载,这意味着后面的js代码都无法继续执行,是无法接受的,而服务器是读取本地资源,速度很快,所以没有影响。</li></ol><h2 id="AMD-了解"><a href="#AMD-了解" class="headerlink" title="AMD (了解)"></a>AMD (了解)</h2><ol><li>定义: 异步加载模块</li></ol><h2 id="CMD-了解"><a href="#CMD-了解" class="headerlink" title="CMD (了解)"></a>CMD (了解)</h2><ol><li>定义: 异步加载模块和CommnonJS的优点</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>NodeJs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误处理方案</title>
    <link href="/2022/04/13/JavaScript/jsBasic_41/"/>
    <url>/2022/04/13/JavaScript/jsBasic_41/</url>
    
    <content type="html"><![CDATA[<h2 id="错误处理方案"><a href="#错误处理方案" class="headerlink" title="错误处理方案"></a>错误处理方案</h2><ol><li>throw 抛出异常,阻止后续代码执行 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 抛出异常throw new Error(  )  &#x2F;&#x2F; 抛出类型异常throw new TypeError( )&#x2F;&#x2F; 抛出语法异常throw SyntaxError( )&#x2F;&#x2F; 抛出下标值越界异常throw RangeError( )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ol><li>如果对异常不处理,那么会一直向外抛出,一直到最顶层调用,如果最顶层也没有对异常处理,那么整个程序就会终止执行</li><li>try{ }catch(err){ }finally{ } 异常捕获</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程&amp;线程&amp;事件循环</title>
    <link href="/2022/04/13/JavaScript/jsBasic_40/"/>
    <url>/2022/04/13/JavaScript/jsBasic_40/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h2><ol><li>Q:什么是进程和线程?<br>A:<br> 进程( process ): 计算机已经运行的程序,是操作系统管理程序的一种方式<br> 线程( thread ): 操作系统能够运行运算调度的最小单位,通常情况下包含在进程中,每个进程至少会有一个线程用来执行程序中的代码,一般称这个线程为主线程<blockquote><p>所以说 进程是线程的容器</p></blockquote></li></ol><h2 id="JavaScript线程"><a href="#JavaScript线程" class="headerlink" title="JavaScript线程"></a>JavaScript线程</h2><ol><li>定义: JavaScript是单线程的,进程容器就是: Node或者浏览器<br> 这就意味着js的代码在同一时刻只能做一件事情,如果这件事非常耗时,就意味着当前的线程会被阻塞<br> 所以真正耗时的操作（网络请求，定时器），不应该由js线程执行，而是通过浏览器的其它线程执行，js只需要在获取浏览器通知（事件循环）执行回调获取结果即可</li></ol><blockquote><p>注意: 浏览器是多进程的,当我们打开一个tab页就是一个新的进程,防止一个页面无响应需要重启这个浏览器,每个进程又有多个线程,其中包括了JavaScript代码的线程</p></blockquote><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ol><li>定义: JavaScript线程在执行时,遇到异步任务的代码,会将异步任务放入浏览器其它线程, 该线程会在某一时间将异步任务放入任务队列,js引擎会在任务队列中获取对应的函数并进行执行,执行完成后该事件就结束,整个闭环的就是事件循环</li></ol><h2 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务&amp;微任务"></a>宏任务&amp;微任务</h2>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">宏任务:  script标签, 定时器,ajax, DOM操作, UI Rendering(UI渲染), I&#x2F;O操作(读取文件之类)[node]微任务:  queueMicrotask函数, Promise.then方法, process.nextTick [node]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong><font color="red">规范: 在执行任何的宏任务之前,都需要先保证微任务队列已被清空</font></strong></p></blockquote><h2 id="队列优先级"><a href="#队列优先级" class="headerlink" title="队列优先级"></a>队列优先级</h2><ol><li>main script中的代码优先执行(编写的顶层script代码)</li><li>在执行任何一个宏任务之前,都会先查看微任务队列中是否有任务需要执行<br>(1) 在宏任务执行之前,必须保证微任务队列是空的<br>(2) 如果微任务队列不为空,那么就优先执行微任务队列中的任务</li><li>node中的process.nextTick()在同级微任务中是先执行的</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async await</title>
    <link href="/2022/04/13/JavaScript/jsBasic_39/"/>
    <url>/2022/04/13/JavaScript/jsBasic_39/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>本质是Generator函数和Promise的语法糖(源码类似于上面的代码)</li><li>解释:<br>(1) async(异步的) : 用于声明一个异步函数<br>(2) await : 必须与async搭配使用</li></ol><h2 id="async-异步函数"><a href="#async-异步函数" class="headerlink" title="async(异步函数)"></a>async(异步函数)</h2><ol><li>使用 </li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">async function foo ()&#123;  console.log(1)&#125;console.log(0)foo()console.log(2)--&gt;  0,1,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol start="2"><li>与普通函数区别<br>(1) 异步函数的返回值一定是一个promise, resolve的值就是异步函数return的值,不return默认返回undefined<br>(2) 异步函数的异常结果会作为返回的promise的rejected状态的值,需要通过catch捕获<blockquote><p>注意: 默认情况下,如果不写一些特殊代码,执行顺序和普通函数无异</p></blockquote></li></ol><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><ol><li>使用: 专门用来解析promise,返回promise的resolve结果,如果reject则将reject结果作为异步函数返回值的promise的rejected状态<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">(async () &#x3D;&gt; &#123;  const res&#x3D;await &#123;then(resolve) &#123;resolve(111)&#125; &#125;  console.log(res)&#125;)()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><blockquote><p>注意:await会阻止后续代码执行,必须等到解析的promise对象resolve之后才会正确执行接下来的代码,reject则抛出异常</p></blockquote><blockquote><p><strong>值的注意:</strong> 由于await需要解析完promise的结果才会继续执行接下来的代码,所以await之后的代码相等于一起和.then进入了微任务队列</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generator 解决异步方案</title>
    <link href="/2022/04/13/JavaScript/jsBasic_38/"/>
    <url>/2022/04/13/JavaScript/jsBasic_38/</url>
    
    <content type="html"><![CDATA[<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2>   <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">     &#x2F;* 封装promise异步函数 *&#x2F;   let requestData&#x3D;(param) &#x3D;&gt; &#123;      return new Promise((resolve,reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;          resolve(param)        &#125;,2000);      &#125;)    &#125; &#x2F;* 封装一个生成器 *&#x2F;    let genFn&#x3D;function*() &#123;      &#x2F;* 将promise对象作为结果通过yield返回         调用next函数传递的参数,必须通过上一个yield去接收     *&#x2F;      const value1&#x3D;yield requestData(&#39;aaa&#39;)      const value2&#x3D;yield requestData(value1+&#39;bbb&#39;)      const value3&#x3D;yield requestData(value2+&#39;ccc&#39;)      console.log(value3)    &#125;&#x2F;* 封装生成器递归next函数 *&#x2F;    let deepNext&#x3D;function(genFn) &#123;     &#x2F;&#x2F; 获取生成器对象      let genObj&#x3D;genFn()    &#x2F;&#x2F; 创建递归函数,并接受参数,参数为上一次next函数调用的结果      let deepGen&#x3D;function(res) &#123;        &#x2F;&#x2F; 执行生成器next函数并获得返回的结果  &#123; done:false&#x2F;true, value: promise&#x2F;undefined &#125;        let result&#x3D;genObj.next(res)        &#x2F;&#x2F; 对结果状态进行判断,判断是否已经全部执行完毕,如果全部执行完毕则结束递归        if(result.done) return result.value        &#x2F;&#x2F; 如果没有执行完毕,则调用promise对象,并将回调结果作为参数传递,进行递归调用        result.value.then(res1 &#x3D;&gt; &#123;          deepGen(res1)        &#125;)      &#125;      deepGen()    &#125;&#x2F;* 调用生成器递归函数 *&#x2F;    deepNext(genFn)res  --&gt;  &#39;aaabbbccc&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generator[生成器]</title>
    <link href="/2022/04/13/JavaScript/jsBasic_37/"/>
    <url>/2022/04/13/JavaScript/jsBasic_37/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>是一个特殊的迭代器,是一种函数控制、使用的方案,它可以让我们更加灵活的 控制函数什么时候执行、暂停执行</li><li>生成器函数<br>(1) 定义: function 之后 添加 * 号就是生成器函数,可以搭配 yield 控制代码的执行流程,返回一个生成器(对象)<br>(2) 关键字: yield [控制代码的执行流程] 每一个yield就是一个暂停,yield可以用来返回值<br>(3) 与return 区别 : return 不执行后面的代码,结束执行,yield只是暂停</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let foo&#x3D;function*() &#123;  console.log(1)  yield 2  console.log(3)&#125;let genObj&#x3D;foo()let value&#x3D;genObj.next() --&gt;1console.log(value) --&gt; &#123; done:false, vlaue: 2 &#125;genObj.next() --&gt;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 如果需要在某个yield代码块中获取next函数传递的参数,需要用上一个yield去接收</p></blockquote>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let foo&#x3D;function*() &#123;  let value&#x3D;yield 2  console.log(value**3)  yield 2&#125;let genObj&#x3D;foo()genObj.next()genObj.next(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="return方法"><a href="#return方法" class="headerlink" title="return方法"></a>return方法</h2><ol><li>定义: 终止生成器函数,返回传递的参数,并阻止接下来的next( )方法<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let add&#x3D;function*() &#123;  console.log(11)  let value&#x3D;yield 222 &#x2F;&#x2F; 接收第二个next函数传递的参数  yield 222*value  console.log(3333)&#125;let genAdd&#x3D;add()let value &#x3D; genAdd().return(2) --&gt; &#123; done:true, value: 2 &#125;&#x2F;&#x2F; 不执行genAdd.next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="throw方法"><a href="#throw方法" class="headerlink" title="throw方法"></a>throw方法</h2><ol><li>定义: 终止生成器函数,抛出异常,如果不捕获异常会阻止接下来的next( )方法,捕获则会继续执行接下来的生成器对象方法<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let add&#x3D;function*() &#123;  console.log(11)  yield  try &#123;      console.log(22)      yield  &#125; catch(err) &#123;      console.log(err)  &#125;  yield  console.log(33)&#125;let genAdd&#x3D;add()genAdd.next()genAdd.next()genAdd.throw(&#39;error&#39;)genAdd.next()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h2><ol><li>定义: 迭代可迭代对象<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function* genArr(arr)&#123;  yeild* arr    &#x2F;* 等价于 *&#x2F;  for( item of arr )&#123;      yield item  &#125;&#125; let arr &#x3D; genArr( [1,2,3] )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2022/04/13/JavaScript/jsBasic_36/"/>
    <url>/2022/04/13/JavaScript/jsBasic_36/</url>
    
    <content type="html"><![CDATA[<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h2><ol><li>定义: 是一个对象,用来帮助我们遍历某一个数据结构</li><li>标准[迭代器协议(iterator protocol)]:<br>(1) 必须有一个next函数,并且该函数没有参数或者只有一个参数<br>(2) next函数必须返回一个对象,并且该对象里包含done和value属性<br>   done 属性: 遍历的每一个属性,赋值为false,遍历完成全部属性后,最后会再访问一次,赋值为true,对应value属性的undefined<br>   value属性: 遍历的每项的值,全部的值遍历完成后,最后会再访问一次,生成一个undefined的值对应 done:true<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"> const arr&#x3D;[1,2,3,4,5]let index&#x3D;0const iterObj&#x3D;&#123;  next() &#123;    if(index&gt;&#x3D;arr.length) &#123;      return &#123;done: true,value: undefiend&#125;    &#125; else &#123;      return &#123;done: false,value: arr[index++]&#125;    &#125;  &#125;&#125;console.log(iterObj.next()) --&gt; &#123;done: false, value: 1&#125;console.log(iterObj.next()) --&gt; &#123;done: false, value: 2&#125;console.log(iterObj.next()) --&gt; &#123;done: false, value: 3&#125;console.log(iterObj.next()) --&gt; &#123;done: false, value: 4&#125;console.log(iterObj.next()) --&gt; &#123;done: false, value: 5&#125;console.log(iterObj.next()) --&gt; &#123;done: true, value: undefined&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>备注:如果done一直不为true,那么这个迭代器就是无限迭代器(使用较少)</p></blockquote></li></ol><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><ol><li>定义: 当一个对象实现了iterable protocol(可迭代协议)时,它就是一个可迭代对象</li><li>标准[ 可迭代协议]:<br>(1) 必须实现一个[Symbol.iterator]函数<br>(2) 该函数必须返回一个迭代器</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const interableObj&#x3D;&#123;  names: [1,3,5],  [Symbol.iterator]() &#123;    let index&#x3D;0    return &#123;      next: () &#x3D;&gt; &#123;        if(index&lt;this.names.length) &#123;          return &#123;done: false,value: this.names[index++]&#125;        &#125; else &#123;          return &#123;done: true,value: undefined&#125;        &#125;      &#125;    &#125;  &#125;&#125;console.log(interableObj[Symbol.iterator]().next())--&gt;&#123;done: false,value: 1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong>注意</strong>: for..of..就是调用next函数循环调用的语法糖</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>for..of..语法糖</li><li>展开运算符(对象的展开不是迭代器,而是新的一个语法,因为对象不是可迭代对象)</li><li>解构(对象的解构不是迭代器,而是新的一个语法,因为对象不是可迭代对象)</li><li>new Set( ),Array.from( ),promise.All( )传递的参数都得是可迭代对象</li></ol><h2 id="自定义类可迭代对象"><a href="#自定义类可迭代对象" class="headerlink" title="自定义类可迭代对象"></a>自定义类可迭代对象</h2><ol><li>可以在类里面直接创建[Symbol.iterator]函数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class ClassRom&#123;  constructor()&#123;&#125;    [Symbol.iterator]()&#123;      return &#123;          next:() &#x3D;&gt;&#123;              return &#123; done:false, value:&#39;a&#39; &#125;          &#125;,          &#x2F;* 迭代终止时的提示 *&#x2F;          return: ()&#x3D;&gt;&#123;              console.log( &#39;迭代器终止了~&#39; )              return &#123; done:true, value: undefined &#125;          &#125;      &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise(五)</title>
    <link href="/2022/04/13/JavaScript/jsBasic_35/"/>
    <url>/2022/04/13/JavaScript/jsBasic_35/</url>
    
    <content type="html"><![CDATA[<h2 id="Promise的类方法"><a href="#Promise的类方法" class="headerlink" title="Promise的类方法"></a>Promise的类方法</h2><ol><li>定义:可以直接通过Promise类直接调用的方法</li></ol><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><ol><li>使用: 将现有结果直接转变成一个fulfilled状态的promise对象返回<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const fulPromise &#x3D; Promise.resolve(&#123;name:&#39;nano&#39;&#125;)fulPromise.then( res &#x3D;&gt; console.log(res)  ) --&gt; &#123; name:&#39;nano&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><ol><li>使用: 将现有结果直接转变成一个rejected状态的promise对象返回<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let obj&#x3D;&#123;name: 11&#125;let promiseFn&#x3D;Promise.reject(obj)promiseFn.then(res &#x3D;&gt; &#123;  console.log(res);  &#125;,err &#x3D;&gt; &#123;  console.log(err);   --&gt;   &#123; name: 11 &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: reject方法无论传入的promise对象还是普通的值,都是直接进入rejected状态阶段,直接返回传入的值,不会因为传入了一个promise对象而继续向下判断</p></blockquote></li></ol><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><ol><li>定义: 传入一个数组promise,等所有数组中的所有promise参数都执行成功之后进入fulfilled状态,返回值是一个结果对应的数组,如果数组中任意一个promise参数执行失败,则直接进入rejected状态</li><li>使用场景: 多个接口并发<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Promise.all([promise1,promise2,promise3])  .then(res &#x3D;&gt; &#123;console.log(res)&#125;,err &#x3D;&gt; &#123;&#125;)  --&gt;[res1,res2,res3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 进入rejected状态不意味着promise全部执行结束并且拿不到成功调用的promise的结果</p></blockquote></li></ol><h2 id="Promise-allSettled-ES11"><a href="#Promise-allSettled-ES11" class="headerlink" title="Promise.allSettled [ES11]"></a>Promise.allSettled [ES11]</h2><ol><li>定义: 必须等到所有promise对象有结果才会返回,无论是fulfilled状态还是rejected,都会进入fulfilled状态,该方法最终只有fulfilled状态</li><li>使用场景:解决多个接口并发且其中某个接口报错也不会影响其它结果执行</li><li>使用: 如果promise对象返回的是fulfilled状态,结果则是 { status: ‘fulfilled’, value: resolve的结果 };如果是rejected状态,结果则是 { status:’rejected’, reason: reject的结果 }</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let obj&#x3D;&#123;name: 11&#125;let promiseFn&#x3D;Promise.resolve(obj)let promiseFn2&#x3D;Promise.reject(obj)let promiseFn3&#x3D;Promise.reject(obj)Promise.allSettled([promiseFn,promiseFn2,promiseFn3]).then(res &#x3D;&gt; &#123;console.log(res)&#125;,err &#x3D;&gt; &#123;console.log(err)&#125;)res --&gt; [  &#123; status: &#39;fulfilled&#39;, value: &#123; name:11 &#125; &#125;,  &#123; status: &#39;rejected&#39;, reason: &#123; name:11 &#125; &#125;,  &#123; status: &#39;rejected&#39;, reason: &#123; name:11 &#125; &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><ol><li>定义: 传入一个数组promise,哪一个promise对象先有结果那么就直接返回该promise对象结果,无论是fulfilled状态还是rejected状态</li><li>使用场景: 图片限时加载,如果超过定时器设置的加载时间,就抛出异常</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Promise.race( [ p1,p2] ).then( res &#x3D;&gt;&#123;&#125;,err &#x3D;&gt; &#123;&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><blockquote><p>注意: 即使返回了结果,也并不意味着其它的promise对象终止执行</p></blockquote><h2 id="Promise-any-ES12"><a href="#Promise-any-ES12" class="headerlink" title="Promise.any() [ES12]"></a>Promise.any() [ES12]</h2><ol><li>定义: 传入一个数组promise,只要有一个promise对象返回fulfilled状态,那么整个Promise类返回fulfilled状态,必须全部promise对象都是rejected状态才会返回rejected状态</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Promise.any( [ p1,p2] ).then( res &#x3D;&gt; &#123;&#125;,err &#x3D;&gt; &#123;&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><blockquote><p>注意: 即使返回了结果,也并不意味着其它的promise对象终止执行</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>ES11</tag>
      
      <tag>ES12</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise(四)</title>
    <link href="/2022/04/13/JavaScript/jsBasic_34/"/>
    <url>/2022/04/13/JavaScript/jsBasic_34/</url>
    
    <content type="html"><![CDATA[<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><ol><li><p>当executor抛出异常时,catch方法也会捕获异常(throw new Error( ))</p></li><li><p>catch的链式调用默认捕获第一个promise的异常,如果第一个promise没有抛出异常并且.then函数中直接返回promise的对象且该对象抛出了异常,则捕获.then函数返回的promise对象异常</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;    return new Promise((resolve,reject) &#x3D;&gt; &#123;resolve()&#125;)&#125;promiseFn().then(  res &#x3D;&gt; new Promise((resolve,reject) &#x3D;&gt; &#123;reject(&#39;errr&#39;)&#125;)).catch(err &#x3D;&gt; &#123;console.log(err)&#125;) --&gt; &#39;errr&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>catch方法返回值<br>定义: 也是返回一个新的promise对象,return的值通过resolve传递,所以.catch return的值 需要通过.then获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;  return new Promise((resolve,reject) &#x3D;&gt; &#123;    reject()  &#125;)&#125;&#x2F;*   promiseFn().catch(res &#x3D;&gt; 3) 这个返回值就是 new Promise( (resolve,reject)&#x3D;&gt;&#123; resolve(3) &#125; )*&#x2F;promiseFn().catch(res &#x3D;&gt; 3).then(res &#x3D;&gt; &#123;console.log(res)&#125;) --&gt; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="catch方法补充"><a href="#catch方法补充" class="headerlink" title="catch方法补充"></a>catch方法补充</h2><ol><li>(1) Q: Promise.then( ) 和 Promise.catch( ) 分开调用时为什么会报错?<br>   A: 因为这两个为独立函数,调用时互不影响。promise每次只会返回一个结果, 这样,如果返回的是reject状态,那么.then函数无法处理,就会报错反之也是一样</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123; reject(&#39;err&#39;)&#125;&#x2F;* 无法处理reject的结果,就会报错 *&#x2F;promiseFn.then( res &#x3D;&gt; &#123;&#125; ) --&gt; 报错promiseFn.catch( res &#x3D;&gt; &#123;&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>  (2) 解决<br>    i. then时,传递成功和失败的两个回调函数<br>    ii. catch的链式调用<br>    <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">promiseFn.then( res &#x3D;&gt; &#123;&#125;, err &#x3D;&gt; &#123;&#125; )promiseFn.then( res &#x3D;&gt; &#123;&#125; ).catch( err &#x3D;&gt; &#123;&#125;) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></p><h2 id="finally方法-ES9"><a href="#finally方法-ES9" class="headerlink" title="finally方法(ES9)"></a>finally方法(ES9)</h2><ol><li>定义: 调用promise对象后最终都会调用这个方法</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;  return new Promise((resolve,reject) &#x3D;&gt; &#123;    reject(22)  &#125;)&#125;&#x2F;*   promiseFn().catch(res &#x3D;&gt; 3) 这个返回值就是 new Promise( (resolve,reject)&#x3D;&gt;&#123; resolve(3) &#125; )*&#x2F;promiseFn().catch(err &#x3D;&gt;&#123;&#125;).finally(()&#x3D;&gt;&#123;  console.log(&#39;结束&#39;)&#125;)--&gt; &#39;结束&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>ES9</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise(三)</title>
    <link href="/2022/04/13/JavaScript/jsBasic_33/"/>
    <url>/2022/04/13/JavaScript/jsBasic_33/</url>
    
    <content type="html"><![CDATA[<h2 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h2><ol><li><p>同一个promise的then方法可以调用多次  </p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let fnPromise&#x3D;() &#x3D;&gt; &#123;  return new Promise((resolve,reject) &#x3D;&gt; &#123;resolve(&#39;被调用&#39;)&#125;)&#125;fnPromise().then(res &#x3D;&gt; &#123;console.log(&#96;第一次$&#123;res&#125;&#96;)&#125;)    --&gt; 第一次被调用fnPromise().then(res &#x3D;&gt; &#123;console.log(&#96;第二次$&#123;res&#125;&#96;)&#125;)    --&gt; 第二次被调用fnPromise().then(res &#x3D;&gt; &#123;console.log(&#96;第三次$&#123;res&#125;&#96;)&#125;)    --&gt; 第三次被调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>备注: 只要resolve方法被调用,那么该promise的.then方法都会被调用</p></blockquote></li><li><p>then方法的返回值<br>(1) then方法的返回值是一个promise对象<br>(2) 如果then函数return的是一个普通值(基础/引用类型),那么整个then函数的返回值是一个新的promise对象,里面的resolve传递的是then函数中return的值,所以可以链式调用</p></li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;  return new Promise( (resolve,reject)&#x3D;&gt;&#123;    resolve()  &#125; )&#125;&#x2F;*   promiseFn().then(res &#x3D;&gt; 3) 这个返回值就是 new Promise( (resolve,reject)&#x3D;&gt;&#123; resolve(3) &#125; )*&#x2F;promiseFn().then(res &#x3D;&gt; 3).then(res &#x3D;&gt; &#123;console.log(res)&#125;) --&gt; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>  (3) 如果then函数return的是一个promise对象,依然返回一个新的promise对象,但是resolve中的参数变成了return的promise对象,那么下一个then方法的时机就与return的promise对象有关( 最终变成了resolve中的传参是promise对象的形式 )<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;  return new Promise( ()&#x3D;&gt;&#123;      resolve()  &#125; )&#125;&#x2F;*  promiseFn().then(res &#x3D;&gt; new Promise((resolve)&#x3D;&gt;&#123; resolve() &#125;)) 这个返回值就是 new Promise( (resolve,reject)&#x3D;&gt;&#123; resolve( new Promise((resolve)&#x3D;&gt;&#123;resolve()&#125;))&#125; )  当resolve的参数是promise对象时,则接下来的操作时机就与resolve中的promise对象有关*&#x2F;let value&#x3D;promiseFn().then(res &#x3D;&gt; new Promise((resolve)&#x3D;&gt;&#123; resolve() &#125;)).then(res &#x3D;&gt; &#123;console.log(res)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p><blockquote><p>备注: 如果返回值是一个对象并且该对象实现了thenable,那么也是相同的理论</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise(二)</title>
    <link href="/2022/04/13/JavaScript/jsBasic_32/"/>
    <url>/2022/04/13/JavaScript/jsBasic_32/</url>
    
    <content type="html"><![CDATA[<h2 id="resolve参数"><a href="#resolve参数" class="headerlink" title="resolve参数"></a>resolve参数</h2><ol><li><p>普通参数传递</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn &#x3D; ()&#x3D;&gt;&#123;  return new Promise((resolve,reject)&#x3D;&gt;&#123;    resolve( &#123; name: &#39;nano&#39; &#125; )  &#125;)&#125;promiseFn().then( res &#x3D;&gt; &#123; console.log(res) &#125; ) --&gt; &#123; name: &#39;nano&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong><font color="red">注意: 一次只能传递一个参数</font></strong></p></blockquote></li><li><p>传递promise</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;return new Promise((resolve,reject) &#x3D;&gt; &#123;    resolve(new Promise((resolve,reject) &#x3D;&gt; &#123;        resolve(111)        reject(222)    &#125;))  &#125;)&#125;&#x2F;* 如果是fulfilled状态 *&#x2F;promiseFn().then(res &#x3D;&gt; &#123;console.log(res)&#125;)  --&gt; 111* 如果是rejected状态 *&#x2F;promiseFn().catch(err &#x3D;&gt; &#123;console.log(err)&#125;)  --&gt; 222&#x2F;* 如果是pending状态则.then或者.catch什么都不打印 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong><font color="red">值得注意:</font></strong> 如果resolve传递的是promise函数,那么当前promise函数状态由resolve中传递的promise函数决定</p></blockquote></li><li><p>传入一个对象并且对象中有then方法,那么当前promise函数的状态由对象中的then方法决定,并且该then函数自动创建resolve,reject两个参数</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"> let promiseFn&#x3D;() &#x3D;&gt; &#123;     return new Promise((resolve,reject) &#x3D;&gt; &#123;       resolve(&#123;         &#x2F;* thenable *&#x2F;         then(resolve,reject) &#123;           resolve(22)           reject(33)         &#125;       &#125;)   &#125;)&#125;promiseFn().then(res &#x3D;&gt; &#123;console.log(res)&#125;) --&gt; 22promiseFn().catch(res &#x3D;&gt; &#123;console.log(res)&#125;) --&gt; 33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise(一)</title>
    <link href="/2022/04/13/JavaScript/jsBasic_31/"/>
    <url>/2022/04/13/JavaScript/jsBasic_31/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h2><ol><li>是一种解决异步调用的解决方案</li></ol><h2 id="基础调用"><a href="#基础调用" class="headerlink" title="基础调用"></a>基础调用</h2><ol><li>声明Promise<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;  return new Promise((resolve,reject) &#x3D;&gt; &#123;      setTimeout(() &#x3D;&gt; &#123;          let num&#x3D;Math.floor(Math.random()*10+1)          console.log(num,&#39;num&#39;)          num&gt;Math.floor(Math.random()*10+1)&#x2F;2? resolve(&#39;suc&#39;):reject(&#39;err&#39;)      &#125;,1000)    &#125;)  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>可以在.then函数中传递两个回调函数,第一个接收resolve的值,第二个接收reject的值 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">promiseFn().then((res) &#x3D;&gt; &#123;console.log(res,&#39;res&#39;)&#125;,(err) &#x3D;&gt; &#123;console.log(err,&#39;err&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol><ol start="3"><li>链式调用 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">promiseFn().then((res) &#x3D;&gt; &#123;console.log(res,&#39;res&#39;)&#125;).catch((err) &#x3D;&gt; &#123;console.log(err,&#39;err&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol><ol start="4"><li>当做独立函数调用 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">promiseFn().then((res) &#x3D;&gt; &#123;console.log(res,&#39;res&#39;)&#125;)promiseFn().catch((err) &#x3D;&gt; &#123;console.log(err,&#39;err&#39;)&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li></ol><h2 id="promise的3种状态"><a href="#promise的3种状态" class="headerlink" title="promise的3种状态"></a>promise的3种状态</h2><ol><li>定义:pending(加载) fulfilled(已完成 操作成功) rejected(已拒绝 操作失败)<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let promiseFn&#x3D;() &#x3D;&gt; &#123;   return new Promise((resolve,reject) &#x3D;&gt; &#123;       &#x2F;* 加载状态 *&#x2F;           ...       &#x2F;* fulfilled状态 *&#x2F;           resolve()       &#x2F;* rejected状态 *&#x2F;           reject()    &#125;) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><font color="red"><strong>注意:</strong></font>状态一旦确定,不能更改</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reflect</title>
    <link href="/2022/04/13/JavaScript/jsBasic_30/"/>
    <url>/2022/04/13/JavaScript/jsBasic_30/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>它是一个对象,主要提供了很多操作js对象的方法,像Object中操作对象的方法,一般都通过内置的方法进行操作</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h2><ol><li>和Proxy搭配使用</li><li>Q: 那为什么要用Reflect而不是Object?<br>A: Object为构造函数,这些操作不合适,并且还包含了in、delete操作符,让JS看起来会有一些奇怪<blockquote><p>注意: 如果可以使用Reflect那么尽量使用Reflect</p></blockquote></li></ol><h2 id="Reflect常见方法"><a href="#Reflect常见方法" class="headerlink" title="Reflect常见方法"></a>Reflect常见方法</h2><ol><li>定义: 和proxy的13种捕获方法一一对应<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name:&#39;nano&#39;, age: 18 &#125;const objProx &#x3D; new Proxy(obj,&#123;  set(target,key,value,receiver)&#123;    return Reflect.set(target,key,value,receiver)  &#125;&#125;)objProx.age &#x3D; 20console.log(obj) --&gt; &#123; name:&#39;nano&#39;, age: 18 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="receiver参数的作用以及与Proxy中的receiver区别"><a href="#receiver参数的作用以及与Proxy中的receiver区别" class="headerlink" title="receiver参数的作用以及与Proxy中的receiver区别"></a>receiver参数的作用以及与Proxy中的receiver区别</h2><ol><li>定义: Reflect中的receiver是改变原对象中的函数的this指向 </li><li>区别: proxy中的receiver是创建出来的代理对象,Reflect中的receiver是改变原对象中的函数的this指向 <blockquote><p>注意:只有get和set函数有receiver参数 </p></blockquote></li></ol><h2 id="Reflect的construct方法-用的较少"><a href="#Reflect的construct方法-用的较少" class="headerlink" title="Reflect的construct方法(用的较少)"></a>Reflect的construct方法(用的较少)</h2><ol><li>定义: 更改构造函数的类型</li><li>使用: Reflect.construct( 需要转变类型的构造函数, 构造函数参数(数组形式), 目标类型的构造函数 )<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function Student( name,age )&#123;  this.name &#x3D; name  this.age &#x3D; age&#125;function Teacher()&#123; &#125;let teacher &#x3D; Reflect.construct( Student,[&#39;nano&#39;,18], Teacher )console.log(teacher) --&gt; 就变成了Teacher类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监听对象的方式</title>
    <link href="/2022/04/13/JavaScript/jsBasic_29/"/>
    <url>/2022/04/13/JavaScript/jsBasic_29/</url>
    
    <content type="html"><![CDATA[<h2 id="监听对象的操作"><a href="#监听对象的操作" class="headerlink" title="监听对象的操作"></a>监听对象的操作</h2><ol><li>Object.defineProperty( obj,key, { get(){}, set(){}} )<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 监听对象的所有属性 *&#x2F;let obj &#x3D; &#123; name: &#39;nano&#39;, age: 18 &#125;Object.keys.forEach( item &#x3D;&gt; &#123;  let value &#x3D; obj[ item ]  Object.defineProperty( obj, item, &#123; get( )&#123; &#125;, set( newV )&#123; value &#x3D; newV &#125; &#125; )&#125; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>Proxy类监听</li></ol><h2 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h2><ol><li><strong>定义: 如果需要监听一个对象,就对这个对象生成一个代理对象,通过这个代理对象的捕获器去捕捉这个代理对象的值的获取和改变,改变和获取值的操作通过代理对象会直接<font color="red">映射到原对象</font></strong></li><li>使用结构: new Proxy(代理对象, 捕获器[13种])<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name: &#39;nano&#39;, age:18 &#125;const objProxy &#x3D; new Proxy(obj,&#123;  get(target,key,receiver)&#123;    console.log(&#39;watch&#39;)    return target[key]  &#125;,  set(target,key,value,receiver)&#123;    console.log(&#39;change&#39;)    target[key] &#x3D; value  &#125;&#125;)objProxy.name &#x3D; &#39;roily&#39;console.log(objProxy.age)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>get/set捕获器的参数解析<br>(1) target: 代理的目标对象<br>(2) key: 获取和发生变动的键值<br>(3) value: 需要设置的新值 [set捕获器]<br>(4) receiver: 调用的代理对象</li></ol><h2 id="Proxy的捕获器-常用"><a href="#Proxy的捕获器-常用" class="headerlink" title="Proxy的捕获器(常用)"></a>Proxy的捕获器(常用)</h2><ol><li><p>has( target,key )<br>(1) 定义: 判断某个key值是否在代理对象上<br>(2) 注意: 只能拦截<font color="red"> <strong>in 关键字</strong></font>的判断,无法拦截hasOwnProperty()的判断</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name:&#39;nano&#39; &#125;const objProxy &#x3D; new Proxy(obj,&#123;  has(target,key)&#123;    console.log(&#39;监听操作&#39;)    return key in target  &#125;&#125;)&#39;name&#39; in objProxy --&gt; &#39;监听操作&#39;objProxy.hasOwnProperty(&#39;name&#39;) --&gt; 不会触发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>deleteProperty( target,key )<br>(1) 定义: 删除捕获器,捕获delete操作符删除的内容</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name: &#39;nano&#39; &#125;const objProxy &#x3D; new Proxy(obj,&#123;  deleteProperty(target,key)&#123;    console.log( &#39;监听delete操作&#39; )    return delete target.key  &#125;&#125;)delete objProxy.name --&gt; &#39;监听delete操作&#39;console.log(obj) --&gt; &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="Proxy的捕获器-补充"><a href="#Proxy的捕获器-补充" class="headerlink" title="Proxy的捕获器(补充)"></a>Proxy的捕获器(补充)</h2><ol><li><p>getPrototypeOf( )<br>定义: 监听调用Object.getPropertyOf( )获取原型时的操作</p></li><li><p>setPrototypeOf( )<br>定义: 监听调用Object.setPropertyOf( )设置原型时的操作</p></li><li><p>isExtensible( )<br>定义: 判断一个对象是否可扩展时的捕捉</p></li><li><p>preventExtensible( )<br>定义: 监听调用Object.preventExtensions( )时的操作</p></li><li><p>getOwnPropertyDescriptor( )<br>定义: 监听调用Object.getOwnPropertyDescriptor( )时的操作</p></li><li><p>defineProperty( )<br>定义: 监听调用Object.defineProperty( )时的操作</p></li><li><p>ownKeys( )<br>定义: 监听调用Object.getOwnPropertyNames( )或Object.getOwnPropertySymbols( )时的操作</p></li><li><p>apply( target,this,argArray )<br>(1)定义: 监听函数调用的操作</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">functin add()&#123;&#125;let proxyAdd &#x3D; new Proxy( add,&#123;  apply( target,_this,applyArg )&#123;    return target.apply(_this,applyArg)  &#125;&#125; )proxyAdd.apply(&#123;&#125;,[1,2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 用于函数对象</p></blockquote></li><li><p>construct(target,argArray,newTarget )<br>(1)定义: 监听new操作符</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">functin add()&#123;&#125;let ProxyAdd &#x3D; new Proxy( add,&#123;  construct( target,argArray,newTarget )&#123;    return new target(...argArray)  &#125;&#125; )new ProxyAdd( )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 用于函数对象</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES12常用语法</title>
    <link href="/2022/04/13/JavaScript/jsBasic_28/"/>
    <url>/2022/04/13/JavaScript/jsBasic_28/</url>
    
    <content type="html"><![CDATA[<h2 id="FinalizationRegistry-类"><a href="#FinalizationRegistry-类" class="headerlink" title="FinalizationRegistry (类)"></a>FinalizationRegistry (类)</h2><ol><li>定义:用来监听GC之前的回调</li><li>使用: 通过声明FinalizationRegistry类,调用原型上的register方法检测GC回收之前的状态<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const finalRegistry &#x3D; new FinalizationRegistry( (objName)&#x3D;&gt;&#123; console.log(objName + &#39;被回收了&#39;) &#125; )let obj &#x3D; &#123; name:&#39;nano&#39; &#125;&#x2F;*  调用类上的 register 方法 ,传入两个参数 第一个参数为需要监听的对象,第二个参数为该对象的标记名称 *&#x2F;finalRegistry.register(obj,&#39;obj&#39;)obj &#x3D; null --&gt; obj被回收了  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 因为GC是不定时回收的,所以打印的时间不是固定的</p></blockquote></li></ol><h2 id="WeakRef-类"><a href="#WeakRef-类" class="headerlink" title="WeakRef (类)"></a>WeakRef (类)</h2><ol><li>定义: 设置对一个对象的引用为弱引用,会被GC回收</li><li>使用: 返回一个WaekRef类,通过deref( )方法获取具体对象内容<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123; name:&#39;nano&#39; &#125;let info &#x3D; new WeakRef( obj )console.log(info.deref( ).name) --&gt; &#39;nano&#39;obj &#x3D; null &#x2F;*  因为是弱引用,当obj这个强引用被释放时,info也会被GC检测释放  返回一个WaekRef类,通过deref方法获取具体对象名称*&#x2F;console.log(info.deref( ).name) --&gt; undefined <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong><font color="red">值得注意</font></strong>: 因为GC机制不是实时的,所以可能还是会获取弱引用中的值,但实际GC回收后就会返回undefined,代码会执行报错</p></blockquote></li></ol><h2 id="逻辑赋值运算符"><a href="#逻辑赋值运算符" class="headerlink" title="逻辑赋值运算符"></a>逻辑赋值运算符</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">  &#x2F;*    ||&#x3D; 逻辑或赋值运算*&#x2F;     let msg &#x3D; &#39;&#39;    msg ||&#x3D; &#39;hello&#39; --&gt;  msg &#x3D; msg || &#39;hello&#39;&#x2F;*     &amp;&amp;&#x3D; 逻辑与赋值运算*&#x2F;    let value &#x3D; &#39;abc&#39;    value &amp;&amp;&#x3D; null --&gt; value &#x3D; value &amp;&amp; value &#x3D; null    console.log( value )  --&gt; null&#x2F;*     ??&#x3D; 逻辑空赋值运算*&#x2F;    let value &#x3D; null    value ??&#x3D; &#39;abc&#39; --&gt; value &#x3D; value ?? value &#x3D; &#39;abc&#39;    console.log( value ) --&gt; &#39;abc&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h2><ol><li>定义:替换字符串中匹配到的全部结果<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let str &#x3D; &#39;abbbbb&#39;let newStr &#x3D; str.replaceAll(&#39;b&#39;,&#39;c&#39;)console.log(newStr) --&gt; &#39;accccc&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES12</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES11常用语法</title>
    <link href="/2022/04/13/JavaScript/jsBasic_27/"/>
    <url>/2022/04/13/JavaScript/jsBasic_27/</url>
    
    <content type="html"><![CDATA[<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><ol><li>定义: 新增的基础数据类型,用来表达更大的数值</li><li>使用: 在大数值的后面加n标记或者使用BigInt( )函数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 获取js基础最大数let maxInt &#x3D; Number.MAX_SAFE_INTEGERconsole.log(maxInt) --&gt; 9007199254740991000&#x2F;&#x2F; 用n标记为BigInt类型let num &#x3D; 9007199254740991000nconsole.log(num)  --&gt; 9007199254740991000n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><font color="red"><strong>值得注意</strong></font>: BigInt类型是不能直接和普通数字类型相加的,没有隐式转换,需要将普通数字类型用n标记为BigInt类型进行相加或者用BigInt( )函数转换类型</p></blockquote></li></ol><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let num &#x3D; 9007199254740991000nlet num2 &#x3D; 10let num3 &#x3D; 10nlet num4 &#x3D; BigInt(10)console.log( num + num2 ) --&gt; 报错console.log( num + num3 ) --&gt; 9007199254740991010nconsole.log (num + num4 ) --&gt; 9007199254740991010n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>提醒: BigInt类型也可以通过Number( )函数转为number类型,但是会数字溢出,计算不准确,所以不推荐使用Number( )转换后去计算</p></blockquote><h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="??(空值合并运算符)"></a>??(空值合并运算符)</h2><ol><li>定义: 如果左侧是null或者undefined时,执行右边的表达式<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let value  &#x3D; null ?? &#39;a&#39;console.log( value ) --&gt; &#39;a&#39;function add()&#123; console.log(&#39;aaa&#39;) &#125;undefined ?? add() --&gt; &#39;aaa&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="可选连操作符"><a href="#可选连操作符" class="headerlink" title="?.(可选连操作符)"></a>?.(可选连操作符)</h2><ol><li>定义: 可以直接判断深层次的数据是否存在,而不会因为前面任意一个变量是undefined或者null而导致报错<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123; name:&#123; age: &#123;&#125; &#125; &#125;&#x2F;&#x2F;会因为age对象中没有year,year为undefined,undefined.number就会报错console.log( obj.name.age.year.number )&#x2F;&#x2F;显示undefined   console.log( obj.name.age.year?.number ) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="globalThis-全局对象"><a href="#globalThis-全局对象" class="headerlink" title="globalThis(全局对象)"></a>globalThis(全局对象)</h2><ol><li>定义: 获取全局对象,不分浏览器和node环境</li><li>出现原因: 浏览器的全局对象通过this或者window获取,node环境下的全局变量获取时global({ })<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">console.log( globalThis )  --&gt;  浏览器执向window  node 指向&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li><p>for…in标准化<br>定义: key只能用来标明对象的键名</p></li><li><p>import动态导入<br>定义: 使用import导入文件之后直接promise方式调用(.then)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES10常用语法</title>
    <link href="/2022/04/13/JavaScript/jsBasic_26/"/>
    <url>/2022/04/13/JavaScript/jsBasic_26/</url>
    
    <content type="html"><![CDATA[<h2 id="flat-amp-flatMap"><a href="#flat-amp-flatMap" class="headerlink" title="flat &amp; flatMap"></a>flat &amp; flatMap</h2><ol><li><p>flat<br>定义: 传递层数进行多维数组降维,返回一个新的一维数组<br>参数: flat(层级数)<br>提示: 如果是不确定层次的多维数组降维,则可以传递参数 <strong>Infinity</strong> 进行全部层次的降维</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const arr &#x3D; [[1],[2],[3,[4,5]],[[[[6,7]]]]]const flatArr &#x3D; arr.flat(Infinity)console.log(flatArr) --&gt; [1,2,3,4,5,6,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p>flatMap<br>定义: 先对数组进行map操作,再进行flat操作,返回一个新的数组<br>参数:flatMap(callback, 层级数)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let arr&#x3D;[&#39;hello world&#39;,&#39;I am a good man&#39;,&#39;shuai bi &#39;]let newArr&#x3D;arr.flatMap((item) &#x3D;&gt; item.trim().split(&#39; &#39;),Infinity)console.log(newArr) --&gt;[&#39;hello&#39;,&#39;world&#39;,&#39;I&#39;,&#39;am&#39;,&#39;a&#39;,&#39;good&#39;,&#39;man&#39;,&#39;shuai&#39;,&#39;bi&#39;] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>值得注意:<br><strong><font color="red">(1) 数组与任意类型相加都会转变为字符串拼接的形式, 对象 类型则是拼接’[object Object]’</font></strong><br><strong><font color="red">(2) 遍历数组的API除了传递回调参数,第二个参数还以可以传递this,用来修改this指向 </font></strong></p></blockquote></li></ol><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><ol><li>定义: 将Object.entries( )转换出来的数据结构返回成对象<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let arr &#x3D; [ [&#39;name&#39;,&#39;nano&#39;], [&#39;age&#39;, 18] ]let obj &#x3D; Object.fromEntries(arr)console.log(obj)--&gt;&#123;  &quot;name&quot;: &quot;nano&quot;,  &quot;age&quot;: 18&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="trimStart-amp-trimEnd"><a href="#trimStart-amp-trimEnd" class="headerlink" title="trimStart &amp; trimEnd"></a>trimStart &amp; trimEnd</h2><ol><li>定义:去除首尾空格<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let str &#x3D; &#39; nano &#39;let trimStart &#x3D; str.trimStart()  console.log( trimStart ) --&gt; &#39;nano &#39;let trimEnd &#x3D; str.trimEnd()console.log(trimEnd) --&gt; &#39; nano&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES8常用语法</title>
    <link href="/2022/04/13/JavaScript/jsBasic_25/"/>
    <url>/2022/04/13/JavaScript/jsBasic_25/</url>
    
    <content type="html"><![CDATA[<h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><ol><li>用法: 获取对象的所有value值并返回一个数组<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name:&#39;nano&#39;,say()&#123;&#125;,skill:[ &#39;JS&#39; ] &#125;const objValues &#x3D; Object.values( obj )console.log( objValues )--&gt; [ &#39;nano&#39;, say(), [ &#39;JS&#39; ] ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2></li><li>用法: 获取到对象中<strong>可枚举</strong>的key/value组成的二维数组<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name:&#39;nano&#39;,say()&#123;&#125;,skill:[ &#39;JS&#39; ] &#125;const objValues &#x3D; Object.entries( obj )console.log( objValues )--&gt; [ [ &#39;name&#39;,&#39;nano&#39; ], [&#39;say&#39;,function()&#123;&#125;], [ &#39;skill&#39;,[&#39;JS&#39;] ] ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="padStart-length-sign-amp-padEnd-length-sign"><a href="#padStart-length-sign-amp-padEnd-length-sign" class="headerlink" title="padStart( length, sign ) &amp; padEnd( length, sign )"></a>padStart( length, sign ) &amp; padEnd( length, sign )</h2><ol><li>定义: 字符串首尾填充,只能填充一次</li><li>参数:<br>length: 填充之后字符串的总长度<br>sign: 填充标记,默认为空格<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let str &#x3D; &#39;nano&#39;console.log( str.padStart(5,&#39;*&#39;) ) --&gt; &#39;*nano&#39;console.log( str.padEnd(5) )  --&gt; &#39;nano &#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><ol><li>定义: 获取对象所有属性描述符</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES7常用语法</title>
    <link href="/2022/04/12/JavaScript/jsBasic_24/"/>
    <url>/2022/04/12/JavaScript/jsBasic_24/</url>
    
    <content type="html"><![CDATA[<h2 id="includes-value-index"><a href="#includes-value-index" class="headerlink" title="includes(value,index)"></a>includes(value,index)</h2><ol><li>判断数组内是否包含某个值,返回布尔值(判断元素为引用类型的值时需要注意指针地址,一般不用来做元素为引用类型的判断)<blockquote><p>值得注意: 可以判断是否包含NaN</p></blockquote></li><li>参数<br>(1) value: 是否包含的值<br>(2) index: 从第几个索引开始判断(可以不传)</li><li>使用<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const arr &#x3D; [ 1,2,3, NaN ]arr.includes(NaN,1) --&gt; 从下标为1的值开始判断,返回结果为truearr.indexOf(NaN)  --&gt; -1 indexOf是判断不出来是否含有NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><ol><li>定义: ** 和Math.pow()的效果一致<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const num1 &#x3D; 2**3const num2 &#x3D; Math.pow(2,3)console.log( num1 ) --&gt; 8console.log( num1 &#x3D;&#x3D;&#x3D; num2 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES7</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法(5)</title>
    <link href="/2022/04/12/JavaScript/jsBasic_23/"/>
    <url>/2022/04/12/JavaScript/jsBasic_23/</url>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol><li>前提:普通对象的key无论写什么类型最后都会转为字符串[除了symbol],而对象类型转为字符串则是’[object Object]’,变成相同key值,后一个会覆盖前一个</li><li>定义:与对象的区别是可以用任意数据类型做为key值且不会转成字符串类型<blockquote><p>注意: 如果是数组作为key存值,那么需要传递entires格式</p></blockquote></li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">  const map &#x3D; new Map()&#x2F;&#x2F; size属性map.size&#x2F;&#x2F; set方法map.set( &#123;name:1&#125;: &#39;2&#39; )&#x2F;&#x2F; get方法map.get( &#123;name:1&#125; ) --&gt; &#39;2&#39; &#x2F;&#x2F; has方法map.has( &#123; name :1&#125; ) --&gt; true&#x2F;&#x2F; delete方法map.delete( &#123; name :1&#125; ) --&gt; true&#x2F;&#x2F;clear方法map.clear()&#x2F;&#x2F; 数组作为keyconst map2 &#x3D; new Map()map2.set( [2,&#39;add&#39;], [ &#123; a: 1 &#125;, &#39;mul&#39; ] )console.log(map2) --&gt; &#123; 2 &#x3D;&gt; &#39;add&#39; ,&#123;a: 1&#125; &#x3D;&gt; &#39;mul&#39;  &#125;&#x2F;&#x2F;遍历mapmap.forEach( (item,key,map) &#x3D;&gt;&#123;  console.log(item) &#125; )for( const item of map)&#123;    item --&gt; [key,value] 的数组&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><ol><li>和Map区别: key只能为对象,对象的引用也是弱引用,如果没有其它对象引用会被GC回收,不能被遍历</li></ol> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Vue3部分原理 *&#x2F;let obj1 &#x3D; &#123; name:&#39;nano&#39;, age:18 &#125;let obj2 &#x3D; &#123; name:&#39;roily&#39;,age:19 &#125;function obj1NameFn1()&#123;&#125;function obj1NameFn2()&#123;&#125;function obj1AgeFn1()&#123;&#125;function obj1AgeFn2()&#123;&#125;function obj2NameFn1()&#123;&#125;function obj2NameFn2()&#123;&#125;&#x2F;&#x2F; 创建Map存储监控的对象和方法let mapObj1 &#x3D; new Map()mapObj1.set(&#39;name&#39;,[ obj1NameFn1, obj1NameFn2 ])mapObj1.set(&#39;age&#39;,[ obj1AgeFn1, obj1AgeFn1 ])&#x2F;&#x2F; 创建weakMap存储对应函数let weakMap &#x3D; new WeakMap( )&#x2F;&#x2F; 这里存储了obj1和监控obj1key值的方法weakMap.set(obj1,mapObj1)&#x2F;&#x2F; 当obj1里其中一个值被改变时obg1.name &#x3D; &#39;Nye&#39;&#x2F;&#x2F; 从weakMap中获取存储的mapObj1数据结构let obj1Map &#x3D; weakMap.get( obj1 )&#x2F;&#x2F; 再从mapObj1中获取对应的方法let fnList &#x3D; obj1Map.get( &#39; name &#39; ) &#x2F;&#x2F;循环调用方法fnList.forEach( item &#x3D;&gt; item( ) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意:当WeakMap取消引用时,Map中存储的也会被消失</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>ES9</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法(4)</title>
    <link href="/2022/04/12/JavaScript/jsBasic_22/"/>
    <url>/2022/04/12/JavaScript/jsBasic_22/</url>
    
    <content type="html"><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ol><li>定义: 类似于数组,但是元素不能重复</li><li>创建Set结构<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let set &#x3D; new Set()set.add(10)set.add(20)set.add(20)set.add(&#123;&#125;)set.add(&#123;&#125;)console.log(set)     --&gt; Set(4) &#123; 10, 20, &#123;&#125;, &#123;&#125; &#125;&#x2F;&#x2F; 删除set.delete( 值 )&#x2F;&#x2F; size属性,判断size长度set.size&#x2F;&#x2F; 判断是否有值set.has(值)&#x2F;&#x2F; 清空setset.clear()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>使用技巧<br>(1) 基础数据类型数组去重<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let arr &#x3D; [1,3,3]let newArr &#x3D; [...new Set(arr)]  &#x2F;&#x2F; 或者 Array.from(new Set(arr))console.log( newArr )  --&gt; [1,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div>(2) forEach/for…of..循环<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let set &#x3D; new Set()set.add(1)set.add(2)set.forEach( item&#x3D;&gt; &#123; console.log(item) --&gt; 1,2 &#125; )for(let item of set)&#123;  console.log(item) --&gt; 1,2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><ol><li>定义:类似于set,与set不同的是 只能存放引用类型并且如果该引用类型没有被其它对象引用,则会被GC回收(<font color="red"><strong>弱引用</strong></font>),不能被遍历</li><li>使用<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let weakSet &#x3D; new WeakSet()weakSet.add(&#123;&#125;)weakSet.add(1) --&gt; 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>ES9</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法(3)</title>
    <link href="/2022/04/12/JavaScript/jsBasic_21/"/>
    <url>/2022/04/12/JavaScript/jsBasic_21/</url>
    
    <content type="html"><![CDATA[<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ol><li>基本语法<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let name &#x3D; &#39;nano&#39;let str &#x3D; &#96;你好$&#123;name&#125;&#96;console.log(str) --&gt; &#39;你好nano&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li>拓展语法<br>(1) 标签模板字符串<br>定义:将模板字符串设置为一种调用函数的方式,第一个参数为数组,里面是模板字符串中的字符串,会根据${}分割,如果没有${}就是存放一整个字符串的数组,${}中的变量会依次传递给剩下的形参<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let foo &#x3D; (m,n,y)&#x3D;&gt;&#123;  console.log(m,n,y)&#125;foo&#96;ab$&#123;18&#125;cd$&#123;20&#125;e&#96;  --&gt; [&#39;ab&#39;,&#39;cd&#39;,&#39;e&#39;],18,20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 默认参数配合解构function add (&#123;name,age&#125; &#x3D; &#123; name:&#39;nano&#39;, age:19 &#125;)&#123;  console.log( name,age ) -&gt; &#39;nano&#39;,19&#125;function add (&#123;name &#x3D; &#39;nano&#39;,age &#x3D; 19&#125; &#x3D; &#123;&#125;)&#123;  console.log( name,age ) -&gt; &#39;nano&#39;,19&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>备注: 有默认参数的形参最好放在最后<br><strong>注意</strong>: 设置默认值的形参以及该形参之后的形参,都不算在函数的length之内<br><strong><font color="red">注意: 设置函数参数默认值后,会形成一个参数作用域,包裹函数作用域,用于保存参数的值</font></strong></p></blockquote><h2 id="收集剩余参数-…"><a href="#收集剩余参数-…" class="headerlink" title="收集剩余参数(…)"></a>收集剩余参数(…)</h2><ol><li>定义: 函数参数中以…为前缀的,它会将剩余的参数放到该参数中并且作为一个数组(必须放到最后一个)</li><li>主要用法:<br>(1) 搭配箭头函数使用<br>(2) 收集指定参数[arguments是函数中所有的参数,而剩余参数则是收集未被形参接住的参数]<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function add(a,b,...args)&#123;  console.log(args) &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li>this永远指向声明箭头函数的那个作用域</li><li>箭头函数的this不受this绑定规则的影响,永远指向声明箭头函数的那个作用域</li><li>箭头函数没有显示原型(prototype)</li><li>箭头函数不能用来作为构造函数</li><li>箭头函数没有arguments,通过搭配剩余参数写法收集参数</li><li>箭头函数都是匿名函数</li><li>箭头函数不能用作生成器(generator)</li></ol><h2 id="展开语法-…"><a href="#展开语法-…" class="headerlink" title="展开语法(…)"></a>展开语法(…)</h2><ol><li>展开语法都是浅拷贝<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ES6:  字符串和数组的展开  let str &#x3D; &#39;abc&#39;  let arr &#x3D; [&#39;f&#39;,&#39;g&#39;]  console.log( [...str,...arr] ) --&gt; [ &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;f&#39;,&#39;g&#39; ]ES9:  对象的展开  let obj &#x3D; &#123; a:1,b:2 &#125;  console.log( &#123;c:3,...obj&#125; ) --&gt; &#123; c:3,a:1,b:2 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: es6字符串和数组的展开语法是因为迭代器的原因,而ES9的对象展开则是内部实现了一个新方法</p></blockquote></li></ol><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ol><li>定义:新增的数据基础类型,但是用法跟函数类似,每次调用都会生成一个独一无二的值</li><li>使用场景: 防止对象key值重名</li><li>用法: Symbol(description)  –&gt; description描述符 </li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let key1 &#x3D; Symbol(&#39;key1&#39;)console.log(key1.description) --&gt; &#39;key1&#39;let key2 &#x3D; Symbol(&#39;key2&#39;)&#x2F;&#x2F; Symbol作为对象的keylet obj &#x3D; &#123; [key1]:1,[key2]:2 &#125;obj[s2] &#x3D; &#39;18&#39;Object.defineProperty( obj, s2, &#123;  ...&#125; )&#x2F;*   Symbol设置为相同的值   Symbol.for(key)*&#x2F;let s1 &#x3D; Symbol.for(&#39;aaa&#39;)let s2 &#x3D; Symbol.for(&#39;aaa&#39;)console.log( s1 &#x3D;&#x3D;&#x3D; s2 ) --&gt; true&#x2F;&#x2F; 如果不用.for的写法,他们是不相等的,因为Symbol每次创建的都是不同的值,即使key相同&#x2F;&#x2F; 获取.for的key值const key &#x3D; Symbol.keyFor(s1)console.log(key) --&gt; &#39;aaa&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong>注意:</strong> Symbol作为key的属性名时,只能通过Object.getOwnPropertySymbol( )的方法获取属性名,其它如遍历,Object.keys( ),Object.getOwnPropertyNames( )都是无法获取的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>ES9</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>class的基本使用</title>
    <link href="/2022/04/12/JavaScript/jsBasic_17/"/>
    <url>/2022/04/12/JavaScript/jsBasic_17/</url>
    
    <content type="html"><![CDATA[<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Person&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="类的表达式-不常用"><a href="#类的表达式-不常用" class="headerlink" title="类的表达式(不常用)"></a>类的表达式(不常用)</h2>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const Person &#x3D; class &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="class的构造函数"><a href="#class的构造函数" class="headerlink" title="class的构造函数"></a>class的构造函数</h2>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Person&#123;  &#x2F;*    1. 创建一个新对象    2. 将构造函数的prototype赋值给新对象的[[prototype]]    3. 将函数的this指向新对象    4. 执行函数代码    5. 返回新对象  *&#x2F;  constructor(name)&#123;    this.name&#x3D; name  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>备注: 如果不写constructor构造函数,会调用默认的构造函数,但是什么都不会做<br>注意: 一个类只能有一个构造函数</p></blockquote><h2 id="class的访问器"><a href="#class的访问器" class="headerlink" title="class的访问器"></a>class的访问器</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Person&#123;  constructor()&#123;      _this.address &#x3D; &#39;abc&#39;  &#125;  get address()&#123;      return this._address  &#125;  set address(value)&#123;      this._address &#x3D; value  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="class的静态方法"><a href="#class的静态方法" class="headerlink" title="class的静态方法"></a>class的静态方法</h2><ol><li>定义: 通过<font color="red"><strong>static</strong></font>关键字声明,可以直接使用 类名访问的方法,而不能使用创建的对象访问<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Person&#123;  constructor(name)&#123;    this.name &#x3D; name  &#125;  static say()&#123;    console.log(&#39;test&#39;)  &#125;&#125;Person.say()  --&gt; &#39;test&#39;const per &#x3D; new Person()per.say() &#x2F;&#x2F; 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法(2)</title>
    <link href="/2022/04/12/JavaScript/jsBasic_20/"/>
    <url>/2022/04/12/JavaScript/jsBasic_20/</url>
    
    <content type="html"><![CDATA[<h2 id="let-amp-const"><a href="#let-amp-const" class="headerlink" title="let&amp;const"></a>let&amp;const</h2><ol><li><p>let&amp;const 共同点:<br>(1) 不允许重复声明变量<br>(2) 没有变量提升(其实在执行上下文阶段被创建出来了,但是不能被访问,从而达到没有变量提升的效果)<br>(3) 设置块级作用域(变量,方法只能在块级作用域内部访问,不能在外部访问)<br>(4) 形成暂时性死区(在块级作用域中,即使外层区域声明过该变量,只要在块级作用域内用let/const声明同名变量,就无法提前访问,此时该块级作用域称为暂时性死区)</p></li><li><p>let&amp;const 不同点:<br> (1) const一般用来声明一个常量,不允许修改,而let是可以多次修改变量值的<br> (2) const声明变量必须有默认赋值,let可以没有默认赋值<br> (3) 如果const声明的是一个引用类型,那么只要不是修改指针地址,而是修改引用类型内部的数据,是可以的,修改引用类型的指针地址是不允许的</p></li></ol><h2 id="let-amp-const与window的关系"><a href="#let-amp-const与window的关系" class="headerlink" title="let&amp;const与window的关系"></a>let&amp;const与window的关系</h2><ol><li>前提: 最新的ECMA标准中,没有VO(变量对象)的概念,取而代之的是VE(变量环境)<br>每一个执行上下文会关联到变量环境(VE)中,在执行代码中变量和函数的声明会作为环境记录(ER)添加到变量环境中,对于函数来说,参数也会被作为环境记录添加到变量环境中</li><li>关系: let和const不会再window对象上添加任何属性,而var声明的变量会在window对象上同步添加,let 和const 的声明的变量保存到VariableMap中,通过HashMap的形式进行存储和查找</li></ol><h2 id="块级作用域补充"><a href="#块级作用域补充" class="headerlink" title="块级作用域补充"></a>块级作用域补充</h2><ol><li><p><strong>部分浏览器为了兼容以前的代码,在块级作用域内,用function直接声明的函数是不受块级作用域限制的,在外部仍然可以访问</strong></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">  &#x2F;* var和function声明的变量和方法都可以在块级作用域外访问 *&#x2F;&#123;  let a &#x3D; 1  var b &#x3D; 2  function add()&#123; console.log(a) &#125;&#125;console.log(a) --&gt; 报错,提示找不到变量aadd() --&gt; 1console.log(b) --&gt; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>if/switch/for<br>这些都是块级作用域(不针对var和function声明的变量和方法)</p></li></ol><h2 id="用-let-for循环-示意代码"><a href="#用-let-for循环-示意代码" class="headerlink" title="用 let for循环 示意代码"></a>用 let for循环 示意代码</h2>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">  for( let i &#x3D; 0 ; i&lt;3 ; i++ )&#123;    console.log( i )  &#125;相当于:    &#123;        let i &#x3D; 0;        console.log( i ) --&gt; 0        i++    &#125;    &#123;        let i &#x3D; 1        console.log( i ) --&gt; 1        i++    &#125;        &#123;        let i &#x3D; 2        console.log( i ) --&gt; 2        i++    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: 这里不能使用const 进行for循环,因为有对原来值进行修改的操作(i++)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法(1)</title>
    <link href="/2022/04/12/JavaScript/jsBasic_19/"/>
    <url>/2022/04/12/JavaScript/jsBasic_19/</url>
    
    <content type="html"><![CDATA[<h2 id="对象字面量增强写法"><a href="#对象字面量增强写法" class="headerlink" title="对象字面量增强写法"></a>对象字面量增强写法</h2><ol><li>属性简写<br>定义: 与key值同名的属性变量,在被对象引用时可以简写为一个key<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let age &#x3D; 18let perston &#x3D; &#123;  age&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>方法简写<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let person &#x3D; &#123;  say()&#123;&#125; --&gt; say:function()&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li>计算属性名(动态key)<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let key &#x3D; &#39;age&#39;let person &#x3D; &#123;  [key +1 ] :18&#125;console.log(person) --&gt; &#123; age1:18 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><ol><li>使用场景: 函数参数/接口回参的解构获取<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 对象解构 按key值进行解构*&#x2F;const &#123; age:value &#125; &#x3D; &#123; age:18 &#125;console.log(value) --&gt;18&#x2F;&#x2F; 只解构后面的元素const &#123;,,c:d&#125; &#x3D; &#123;a:1,b:2,c:3&#125;console.log(d) --&gt;3&#x2F;&#x2F; 只解构第一个元素,其它元素收集到另外的对象里const &#123; a, ...obj &#125; &#x3D;&#123;a:1,b:2,c:3&#125;console.log(obj) --&gt; &#123;a:1,c:3&#125;&#x2F;&#x2F; 对象解构默认值+对象属性简写const &#123;a,b&#x3D;1&#125; &#x3D; &#123; a:2 &#125; --&gt; b:b &#x3D; 1console.log(b) --&gt; 1&#x2F;&#x2F; 嵌套解构const &#123;a:&#123;b&#125;&#125; &#x3D; &#123;a:&#123;b:2&#125;&#125;console.log(b) --&gt; 2注意:此时的a对象则无法单独解构出来使用&#x2F;* 数组解构 按索引顺序进行解构*&#x2F;const [a,b,c] &#x3D; [1,2,3]console.log(a) --&gt; 1&#x2F;&#x2F; 只解构后面的元素const [,,c] &#x3D; [1,2,3]console.log(c) --&gt;3&#x2F;&#x2F; 只解构第一个元素,其它收集到其它数组里const [ a, ...arr ] &#x3D; [1,2,3]console.log(arr) --&gt; [2,3]&#x2F;&#x2F; 数组解构默认值const [a,b&#x3D;1] &#x3D; [2]console.log(b) --&gt; 1&#x2F;&#x2F; 嵌套解构const [[f]] &#x3D; [[1]]console.log(f) --&gt; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类的继承</title>
    <link href="/2022/04/12/JavaScript/jsBasic_18/"/>
    <url>/2022/04/12/JavaScript/jsBasic_18/</url>
    
    <content type="html"><![CDATA[<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ol><li>定义: 使用<font color="red"><strong>extends</strong></font>和<font color="red"><strong>super</strong></font>关键字实现继承    <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Person &#123;  constructor(name, age) &#123;    this.name &#x3D; name    this.age &#x3D; age  &#125;  eating(params) &#123;    console.log(this.name + &#39;吃了&#39; + params)  &#125;  drinking(water)&#123;    return water + this.name  &#125;&#125;&#x2F;* 使用extends关键字使子类继承父类 *&#x2F;class Student extends Person &#123;  constructor(name, age, book) &#123;    &#x2F;* 在子类构造函数中,先调用super构造函数,主要用来调用父类的构造函数,传入对应的参数 *&#x2F;    super(name, age)    this.book &#x3D; book    &#x2F;* 同时也可以通过super调用父类中的方法(包括静态方法) *&#x2F;    this.water &#x3D; super.drinking(water)        &#125;  read() &#123;    console.log(this.book)  &#125;&#125;let stu1 &#x3D; new Student(&#39;nano&#39;, 19, &#39;vue权威指南&#39;)stu1.eating(&#39;饭&#39;) --&gt; nano吃了饭stu1.read()    --&gt;权威指南  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写"></a>子类对父类方法的重写</h2></li><li>定义: 在子类中写一个与父类同名的方法,会优先调用子类中的方法<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class Person &#123;  constructor(name) &#123;    this.name &#x3D; name  &#125;  eating(params) &#123;    console.log(this.name + &#39;吃了&#39; + params)  &#125;&#125;&#x2F;* 使用extends关键字使子类继承父类 *&#x2F;class Student extends Person &#123;  constructor(name) &#123;  &#x2F;* 在子类构造函数中,先调用super构造函数,主要用来调用父类的构造函数,传入对应的参数 *&#x2F;  super(name)&#125;  &#x2F;* 写一个与父类同名的方法eating,进行方法的重写 *&#x2F;  eating(params) &#123;    &#x2F;* 同时可以通过super复用父类中的方法逻辑 *&#x2F;    super.eating(&#39;饭&#39;)    console.log(&#39;子类吃吃吃!&#39;+params )  &#125;&#125;let stu1 &#x3D; new Student(&#39;nano&#39;)stu1.eating(&#39;饭&#39;) --&gt; nano吃了饭 子类吃吃吃!饭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="继承内置类"><a href="#继承内置类" class="headerlink" title="继承内置类"></a>继承内置类</h2>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">class NanoArray extends Array &#123;  firstItem() &#123;    return this[0]  &#125;&#125;let arr &#x3D; new NanoArray(1, 2, 3)console.log(arr.firstItem())  --&gt; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象上的一些方法</title>
    <link href="/2022/04/12/JavaScript/jsBasic_16/"/>
    <url>/2022/04/12/JavaScript/jsBasic_16/</url>
    
    <content type="html"><![CDATA[<h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h2><ol><li>定义: 判断某个属性是否在自身对象上(不包含原型) 返回布尔值<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name:&#39;nano&#39; &#125;&#x2F;&#x2F; 在原型对象上设置属性Object.setPrototypeOf( obj, &#123; age:19 &#125;)const res1 &#x3D; obj.hasOwnProperty(&#39;name&#39;) --&gt; trueconst res2 &#x3D; obj.hasOwnProperty(&#39;age&#39;)  --&gt; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2></li><li>定义: 判断某个属性是否在对象上(包含原型链) 返回布尔值<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name:&#39;nano&#39; &#125;&#x2F;&#x2F; 在原型对象上设置属性Object.setPrototypeOf( obj, &#123; age:19 &#125;)const res1 &#x3D; &#39;name&#39; in obj --&gt; trueconst res2 &#x3D; &#39;age&#39; in obj  --&gt; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a>instance of</h2><ol><li>定义: 检测构造函数的prototype是否会出现在每个实例对象的原型链上</li></ol><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h2><ol><li>定义: 用于检测某个对象,是否出现在某个实例对象的原型链上<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Array.prototype.isPrototypeOf([1]) --&gt; true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2022/04/12/JavaScript/jsBasic_15/"/>
    <url>/2022/04/12/JavaScript/jsBasic_15/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript是单继承的,只能继承一个父类</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ol><li>定义: 子类构造函数的prototype指向父类创建出来的对象</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function Person(name,age)&#123;  this.name &#x3D; name  this.age &#x3D; age  this.run &#x3D; function()&#123; return &#39;run&#39; &#125;&#125;function Student( stNo )&#123;  this.stNo &#x3D; stNo&#125;Student.prototype &#x3D; new Person(&#39;nano&#39;,18)const stu1 &#x3D; new Student(11)let run &#x3D; stu1.run()console.log(run) --&gt; run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol start="2"><li>缺点</li><li>继承的属性无法打印出来,因为是原型属性[[prototype]], 不可枚举</li><li>如果父类里的值是引用类型,某个子类在修改该引用类型的值时其它子类也会被影响</li><li>声明子类的时候无法传递参数直接赋值给继承父类的属性,必须得在父类声明时传递</li></ol><h2 id="借助构造函数继承"><a href="#借助构造函数继承" class="headerlink" title="借助构造函数继承"></a>借助构造函数继承</h2><ol><li>在原型链继承的基础上借用构造函数继承</li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function Person(name,age)&#123;  this.age &#x3D; age  this.name &#x3D; name  this.say &#x3D; function()&#123; console.log(this.name) &#125;&#125;function Student(name,age,stNo)&#123;  &#x2F;*     借助构造函数,指定this的绑定,这样实现子类传递参数,父类统一接收    在子类的函数this中添加了属性,这样就可以打印出来    每次调用子类,都会独有this,这样解决了引用类型指针共享的问题  *&#x2F;  Person.call(this,name,age)  this.stNo &#x3D; stNo  this.run &#x3D; function()&#123; console.log( &#39;run&#39;) &#125;&#125;Student.prototype &#x3D; new Person()const stu &#x3D; new Student(&#39;nano&#39;, 19, &#39;05&#39;)console.log( stu )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol start="2"><li>优点: 解决了原型链继承的全部问题</li><li>缺点:<br> (1) 父类函数至少被调用了两次<br> (2) 子类的原型对象[[prototype]]上会多一些没有必要存在的属性</li></ol><h2 id="寄生式继承-针对于对象"><a href="#寄生式继承-针对于对象" class="headerlink" title="寄生式继承(针对于对象)"></a>寄生式继承(针对于对象)</h2><ol><li>定义: 原型继承结合工厂模式<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 父类let personObj &#x3D; &#123;  running()&#123;    console.log(&#39;run&#39;)  &#125;&#125;&#x2F;&#x2F; 工厂函数function createStu(personObj,name)&#123;  &#x2F;&#x2F; 创建一个原型指向父类的子类  let obj &#x3D; Object.create(personObj)  obj.name &#x3D; name  obj.say &#x3D; function()&#123;&#125;  return obj&#125;let stu1  &#x3D; createStu(personObj, &#39;nano&#39;)let stu2  &#x3D; createStu(personObj, &#39;roily&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>缺点:<br>(1) 重复创建函数<br>(2) 无法知道是什么类型的类</li></ol><h2 id="寄生组合式继承-最终方案"><a href="#寄生组合式继承-最终方案" class="headerlink" title="寄生组合式继承(最终方案)"></a>寄生组合式继承(最终方案)</h2><ol><li>定义: 将借助构造函数继承和寄生式继承结合<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 为了方法复用,往往会封装一个工具函数function inherit(parent,child)&#123;  child.prototype &#x3D; Object.create(parent.prototype)  Object.defineProperty(child.prototype,&#39;constructor&#39;,&#123;    value:child,    configure:true,    enumerable:false,    writable:true     &#125;)&#125;function Parent(name,age)&#123;  this.name &#x3D; name  this.age &#x3D; age  this.say &#x3D; function()&#123;&#125;&#125;fcuntion Child(name,age,sno)&#123;  Parent.call(this,name,age)  this.sno &#x3D; sno  this.study &#x3D; function ()&#123;&#125;&#125;&#x2F;* 没有进行函数复用封装  &#x2F;&#x2F; 寄生式继承,Object.create用来创建一个原型[[prototype]]指向父类的空对象  Child.prototype &#x3D; Object.create(Parent.prototype) --&gt; createObj(Parent.prototype) [createObj函数在下方]  &#x2F;&#x2F; 将寄生式继承的名称由父类改为子类,实际就是更改显示原型上constructor函数的指向     Object.defineProperty(Child.prototype,&#39;constructor&#39;,&#123;      value:Child, &#x2F;&#x2F;  constructor 指向构造函数      configure:true,      enumerable:false,      writable:true     &#125;)*&#x2F;&#x2F;&#x2F; 进行函数复用封装inherit(Parent,Child)Child.prototype.eating &#x3D; function( )&#123;&#125;&#x2F;&#x2F; 如果不适用Object.create()函数该如何实现寄生式继承?  function createObj(o)&#123;      &#x2F;&#x2F; 声明一个新函数    function Foo()&#123;&#125;      &#x2F;&#x2F; 将该函数的显示原型指向传进来的对象    foo.prototype &#x3D; o      &#x2F;&#x2F; 返回new出来的对象,该对象的原型指向Foo的prototype,指向o    reutrn  new Foo()  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意: ES6的class继承就是该模式的语法糖</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2022/04/12/JavaScript/jsBasic_14/"/>
    <url>/2022/04/12/JavaScript/jsBasic_14/</url>
    
    <content type="html"><![CDATA[<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol><li>什么是原型链?<br>当在一个对象上找不到某个属性或者方法时,会去该对象的原型对象中([[prototype]])查找,如果该对象的原型对象也没有该属性,那么会在原型对象的原型对象中查找,这样逐层查找原型对象直到查到顶层对象,这样的链式查找就是原型链。</li></ol><blockquote><p>注意: Object是所有类的父类,他的[[prototype]]是null</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐式原型和显示原型</title>
    <link href="/2022/04/12/JavaScript/jsBasic_13/"/>
    <url>/2022/04/12/JavaScript/jsBasic_13/</url>
    
    <content type="html"><![CDATA[<h2 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h2><ol><li>什么是隐式原型?<br>定义: 每一个对象都有一个隐式原型(<strong><font color="red">[[prototype]]</font></strong>)</li><li>作用<br>用来继承构造函数中的prototype(显示原型)指针</li><li>如何获取这个隐式原型?<br>(1) 绝大部分浏览器都给对象内置了__proto__属性,可以通过__proto__获取对象的原型<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj  &#x3D; &#123; name: &#39;nano&#39; &#125;const objProto &#x3D; obj.__proto__console.log(objProto)  --&gt; Obejct的prototype<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div>缺点:  部分浏览器可能不支持</li></ol><p>  (2) <strong>Object.getPrototypeOf() [ES5之后出现的方法]</strong><br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj  &#x3D; &#123; name: &#39;nano&#39; &#125;const objProto &#x3D; Object.getPrototypeOf(obj)console.log(objProto) --&gt; Obejct的prototype<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></p><h2 id="显示原型"><a href="#显示原型" class="headerlink" title="显示原型"></a>显示原型</h2><ol><li>什么是显示原型?<br>定义: <strong>函数对象</strong>的<strong>专有</strong>属性(prototype)</li><li>作用<br>用来存储一些公用的方法和变量,并传递指针地址给调用该构造函数创建出来的对象的[[prototype]] (隐式原型)<br>每个prototype中都含有一个constructor属性,该属性指向构造函数本身</li><li>Q: 如何巧妙添加的在prototype添加多个属性?<br>A:  将prototype指向新对象<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function Vue()&#123;&#125;Vue.prototype &#x3D; &#123;  constructor: Vue,    &#x2F;&#x2F; 原本prototype中就含有constructor属性,并且指向这个函数本身  name:&#39;nano&#39;,  age:18&#125;let Vue &#x3D; new Vue()console.log(Vue.age) --&gt; 18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong>注意</strong>: 其实这里不应该直接在新对象中添加添加constructor属性,因为在原始的prototype中它是一个不可枚举的属性,所以需要单独使用Object.defineProperty()进行添加</p></blockquote></li></ol><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function Vue()&#123;&#125;Vue.prototype &#x3D; &#123;  name:&#39;nano&#39;,  age:18&#125;Object.defineProperty(Vue.prototype,&#39;constructor&#39;,&#123;  value: Vue,  configure: true,  enumerable: false,  writable: true&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量创建对象的方法</title>
    <link href="/2022/04/12/JavaScript/jsBasic_12/"/>
    <url>/2022/04/12/JavaScript/jsBasic_12/</url>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ol><li><p>什么是工厂模式?<br>定义: 封装一个方法调用即可创建多个对象</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function createObj( name,age,height )&#123;  let obj &#x3D; new Object( )  obj.name &#x3D; name  obj.age &#x3D; age  obj.height &#x3D; height  obj.say( ) &#x3D; fucntion ( )&#123;&#125;  return obj&#125;let nano &#x3D; createObj(&#39;nano&#39;,18,188)let roily &#x3D; createObj(&#39;roily&#39;,18,188)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>缺点: 获取不到对象最真实的类型,返回的值都是一个字面量</p></li></ol><h2 id="构造函数-ES5"><a href="#构造函数-ES5" class="headerlink" title="构造函数[ES5]"></a>构造函数[ES5]</h2><ol><li><p>什么是构造函数?<br>定义: 通过 new 来执行的一个函数</p></li><li><p>使用</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function Person(name,age)&#123;  this.name &#x3D; name  this.age &#x3D; age  this.run &#x3D; function()&#123; console.log(&#39;run&#39;) &#125;&#125;Person.prototype.say &#x3D; function()&#123; console.log( &#39;hello&#39; ) &#125;const student &#x3D; new Person(&#39;nano&#39;, 20)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>new的作用<br>(1) 创建一个新的对象<br>(2) 将该构造函数的prototype(显式原型) 赋值给该对象的__proto__属性(隐式原型)<br>(3) 将构造函数的this指向这个新对象<br>(4) 执行函数内部代码<br>(5) 如果构造函数没有返回非空对象,则返回创建出来的对象</p></li><li><p>缺点<br>缺点: 每用构造函数创建对象时,里面的方法都会创建一个新的地址占据内存,明明是一样功能的方法<br>解决: 直接将共用的方法或者变量放在构造函数的显示原型(prototype)上</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.defineProperty解析</title>
    <link href="/2022/04/12/JavaScript/jsBasic_11/"/>
    <url>/2022/04/12/JavaScript/jsBasic_11/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li><p>直接定义一个对象上的新属性或者修改一个对象上的现有属性,并返回此对象</p></li><li><p>接收的参数<br>(1) target 目标对象<br>(2) key 新的属性名或者需要修改的属性名(字符串)<br>(3) desc 属性描述符[ 数据属性描述符(默认都为false ),访问器属性描述符 ](对象)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; name: &#39;nano&#39; &#125;Object.defineProperty( obj, &#39;name&#39;, &#123;  value: &#39;roily&#39;,  configure: false,  enumerable:false,  writable:false       &#125; )console.log( obj ) --&gt; &#123; name:&#39;roily&#39; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>属性描述符<br>(1) value<br>定义: 属性的值<br>默认值:undefined</p></li></ol><p>  (2) configure<br>   定义: 是否可配置(可删除)<br>   默认值:false</p><p>  (3) enumerable<br>    定义: 是否可枚举(for..key..,Object.keys())<br>    默认值:false</p><p>  (4) writable<br>    定义: 是否可写(可修改)<br>    默认值:false</p><ol start="4"><li>访问器属性描述符<br>定义:<br>   (1) 隐藏某一个私有属性,不希望被外界直接使用<br>   (2) 截获某一个属性访问和设置值的过程<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const obj &#x3D; &#123; _name:&#39;nano&#39; &#125;Object.defineProperty( obj, &#39;name&#39;,&#123;  get()&#123;    return this._name  &#125;,  set(value)&#123;    this._name &#x3D; value  &#125;,  configure: true,  enumerable: true&#125; )console.log( obj ) --&gt; &#123; _name:&#39;nano&#39; &#125;console.log( obj.name ) --&gt; &#39;nano&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>注意:<br>(1)定义的访问器属性并不会直接出现在对象里<br>(2)<strong><font color="red">访问器属性描述符不能与value,writable这两个属性描述符一起使用</font></strong></p></blockquote></li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li><p>Object.defineProperties<br>定义: 直接定义多个对象上的新属性或者修改一个对象上的现有属性,并返回此对象</p></li><li><p>接收的参数<br>(1) target 目标对象<br>(2) descs 多个属性描述符集合(对象)</p></li><li><p>使用</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">let obj &#x3D; &#123; _age:19 &#125;Object.defineProperties(obj,&#123;  name:&#123;      value: &#39;abc&#39;,      configure: true,      enumerable: true,      writable: true  &#125;,  age:&#123;      configure: true,      enumerable: true,      get( )&#123;        return this._age      &#125;,      set(value )&#123;        this._age &#x3D; value      &#125;  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合函数</title>
    <link href="/2022/04/12/JavaScript/jsBasic_10/"/>
    <url>/2022/04/12/JavaScript/jsBasic_10/</url>
    
    <content type="html"><![CDATA[<h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><ol><li>定义: 多个函数组合成一个新的函数(需要注意函数的调用顺序)<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;  function add(a) &#123;    return a+&#x3D;5  &#125;  function mul(b) &#123;    return b-&#x3D;5  &#125;  function comp(add,mul) &#123;    return function(v) &#123; return mul(add(v)) &#125;  &#125;  let foo&#x3D;comp(add,mul)  console.log(foo(5))&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>封装组合函数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;  function comp(...fns) &#123;    let length&#x3D;fns.length      &#x2F;&#x2F; 判断参数是否都是函数类型    for(let i&#x3D;0;i&lt;length;i++) &#123;      if(!typeof fns[i]&#x3D;&#x3D;&#x3D;&#39;function&#39;) &#123;        throw TypeError(&#39;expect function&#39;)      &#125;    &#125;        &#x2F;&#x2F; 最终返回一个新函数,用来传入参数    return function(...args) &#123;      &#x2F;&#x2F; 依次调用函数数组      let index&#x3D;0      &#x2F;&#x2F; 收集到全部参数是个数组,完成第一层函数逻辑之后返回结果,将结果传递给下一层函数      &#x2F;&#x2F; 这里就需要处理好函数之间的调用逻辑      let res&#x3D;length? fns[index].apply(this,args):args    &#x2F;&#x2F; 如果没有传递函数,就直接返回传递的参数      while(++index&lt;length) &#123;        &#x2F;&#x2F; 这里用call比较合适,用apply也可以,但是得套用一层[]        res&#x3D;fns[index].call(this,res)      &#125;      &#x2F;&#x2F; 返回最终的结果      return res    &#125;  &#125;  let a&#x3D;function(v) &#123;    return v*5  &#125;  let b&#x3D;function(v) &#123;    return v&#x2F;5  &#125;  &#x2F;&#x2F; 产生一个新函数用来传递参数  let fn&#x3D;comp(a,b)  console.log(fn(5)) --&gt; 5&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2022/04/12/JavaScript/jsBasic_09/"/>
    <url>/2022/04/12/JavaScript/jsBasic_09/</url>
    
    <content type="html"><![CDATA[<h2 id="纯函数-pure-function"><a href="#纯函数-pure-function" class="headerlink" title="纯函数(pure function)"></a>纯函数(pure function)</h2><ol><li><p>定义:<br>(1) 相同的输入产生相同的结果</p><blockquote><p>详解:<strong><font color="red">入参类型相同且 return 的值格式相同,如果给定相同的参数，则得到相同的结果 </font>,有输入就一定有输出</strong></p></blockquote><p> (2) 不会产生副作用  </p><blockquote><p>详解:<strong><font color="red">不会影响其它作用域的变量的值,不会更改页面的显示,不会对内存存储进行改变等等 </font></strong></p></blockquote><p> (3) 只通过return返回输出的值,不会在其它地方打印</p></li><li><p>优势<br>只需要关注函数内部的逻辑,更能提高专注开发</p></li></ol><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><ol><li>定义: 只传递给函数一部分参数来调用它,让它返回一个函数去处理剩余的参数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 原函数  function foo( x,y,z )&#123;    return x+y+z  &#125;foo(1,2,3)&#x2F;&#x2F; 柯里化函数  function foo(x)&#123;    return function(y)&#123;      return function(z)&#123;        return x+y+z      &#125;    &#125;  &#125;foo(1)(2)(3)&#x2F;&#x2F; 箭头函数let foo &#x3D; x&#x3D;&gt;y&#x3D;&gt;z&#x3D;&gt; x+y+zfoo(1)(2)(3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>作用<br>(1) <strong><font color="red">单一职责原则</font></strong>: 尽量让每个函数处理单一的业务逻辑,再将该函数的处理结果传递给下一个函数进行下一项任务逻辑的处理<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo(x)&#123;  x*&#x3D;2  return function(y)&#123;    y+&#x3D;1    return function(z)&#123;      return x+y+z    &#125;  &#125;&#125;foo(1)(2)(3) --&gt; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>(2) 对某段代码逻辑复用 <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo(x)&#123;  x*&#x3D;2  return function(y)&#123;    y+&#x3D;1    return function(z)&#123;      return x+y+z    &#125;  &#125;&#125;&#x2F;&#x2F; 这里就对x*&#x3D;2这段代码进行了复用let bar2 &#x3D; foo(2)bar2(3)(4)bar2(5)(6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>柯里化函数的封装实现<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function hyCurrying(fn)&#123;  return function curried(..args)&#123;      &#x2F;&#x2F; 判断收集的参数是否大于等于需要柯里化函数的参数总长度,如果大于等于则执行传递过来的函数     if(args.length &gt;&#x3D; fn.length)&#123;          &#x2F;&#x2F; 如果大于,则直接调用fn函数,并将this执向一直绑定在curried函数内部,否则视为独立函数调用指向window          return fn.apply(this,args)      &#125;else&#123;          &#x2F;&#x2F; 如果没有达到所需参数的格式则递归调用检查是否达到所需参数长度,没有达到则拼接参数          return function curried2(...args2)&#123;              return curried.apply(this,args.concat(args2))          &#125;      &#125;  &#125;&#125;let  foo &#x3D; hyCurrying(fn)foo(1)(2)(3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的arguments</title>
    <link href="/2022/04/12/JavaScript/jsBasic_08/"/>
    <url>/2022/04/12/JavaScript/jsBasic_08/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是函数的arguments"><a href="#什么是函数的arguments" class="headerlink" title="什么是函数的arguments?"></a>什么是函数的arguments?</h2><ol><li>定义: 是函数内置的函数参数的一个集合,是一个类数组对象,每一个函数都有该属性<blockquote><p><strong>注意:</strong> 箭头函数是没有arguments的,与ES6的剩余参数做搭配</p></blockquote></li></ol><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><ol><li><p>获取参数长度</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;  console.log( arguments.length )&#125;foo(1,2,3,4) --&gt; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>备注: 通过函数名称.length也可以获取参数长度</p></blockquote></li><li><p>根据索引值获取对应的参数</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;  console.log( arguments[0] )&#125;foo(1,2,3,4) --&gt;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>callee获取当前arguments所在的函数</p>   <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;  console.log( arguments.callee )&#125;foo(1,2,3,4) --&gt; &#39;foo&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>将arguments转为数组</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;  let newArg1 &#x3D; [ ...arguments ]  let newArg2 &#x3D; Array.from(arguments)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this</title>
    <link href="/2022/04/12/JavaScript/jsBasic_07/"/>
    <url>/2022/04/12/JavaScript/jsBasic_07/</url>
    
    <content type="html"><![CDATA[<h2 id="不同环境下的全局this指向"><a href="#不同环境下的全局this指向" class="headerlink" title="不同环境下的全局this指向"></a>不同环境下的全局this指向</h2><ol><li>在浏览器环境下,this指向了window</li><li>在node的环境下,this指向了global({})</li></ol><blockquote><p>因为不同环境this的指向不一致,所以在ES11的时候新增了一个属性:<strong>GlobalThis</strong>,根据不同环境动态指向对应的全局this</p></blockquote><h2 id="函数this的指向"><a href="#函数this的指向" class="headerlink" title="函数this的指向"></a>函数this的指向</h2><ol><li>在执行函数执行栈(FEC)时,会创建VO,scope chain和this<br>这时的this是动态绑定的,不是创建时绑this定而是在函数使用时绑定,跟函数定义在哪没有关系</li></ol><h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><ol><li><p>默认绑定<br>定义: 默认情况下,如果一个函数独立调用,那么该函数的this指向全局</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;&#125;&#x2F;&#x2F; 独立函数调用,此时的this指向全局(window&#x2F;global )foo()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p>隐式绑定<br>定义: 将函数称为某个对象的方法,通过调用该对象进行this绑定,那么这个this指向的就是这个对象,这个方法是被哪个对象调用的,那么那个对象就是该函数的this</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123;&#125;const obj &#x3D; &#123;  foo: foo&#125;&#x2F;&#x2F; 此时函数的this指向了obj这个对象obj.foo() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>显示绑定<br>(1) call(),apply(),bind()</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo()&#123; console.log(this.name) &#125;const obj &#x3D; &#123;  name:&#39;roily&#39;,  foo&#125;const thisObj &#x3D; &#123; name:&#39;nano&#39; &#125;&#x2F;* 此时的this指向了thisObj这个对象 *&#x2F;foo.call(thisObj)  --&gt;  &#39;nano&#39;obj.foo.apply(thisObj)  --&gt;  &#39;nano&#39;obj.foo.bind(thisObj)  --&gt;  &#39;nano&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>(2) call,apply,bind区别<br>   i. call,apply 传递的参数不同,call是单个参数单个参数传递的,apply是传递一个数组<br>   ii.call再执行后就会立即销毁,而bind是返回一个函数,该函数的this永久指向bind绑定的this对象</p></li><li><p>new绑定<br>(1) 定义: 构造函数的new绑定<br>(2) new的用途:<br>   i. 创建一个空对象<br>   ii.将构造函数的显示原型赋给该对象的原型对象<br>  iii.将构造函数的this指向这个空对象<br>   V. 执行构造函数的代码<br>  IV. 返回该对象</p></li></ol><h2 id="绑定规则优先级"><a href="#绑定规则优先级" class="headerlink" title="绑定规则优先级"></a>绑定规则优先级</h2><ol><li>new &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</li></ol><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><ol><li><p>忽略显示绑定<br>当call,apply,bind传递的this对象为null或undefined时,那么此时的this指向全局</p></li><li><p>箭头函数的this<br><strong>箭头函数的this是不受所有的this绑定规则影响的,永远指向声明箭头函数的那个作用域</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2022/04/12/JavaScript/jsBasic_06/"/>
    <url>/2022/04/12/JavaScript/jsBasic_06/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包?"></a>什么是闭包?</h2><ol><li><p>一个普通的函数,如果可以访问外层作用域的变量,那么这就是一个闭包</p></li><li><p>广义的角度上: JS的函数都是闭包<br>狭义的角度上: JS中的一个函数,内部引用了外部作用域的变量,那就是闭包</p></li></ol>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo( param &#x3D; 1 )&#123;  return function()&#123;    return param +&#x3D; 1  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol start="3"><li><p>闭包的内存泄漏<br>原因: 因为闭包函数存在就会一直引用着父级函数的作用域中内存,如果只是调用了一次闭包函数并且不进行销毁,那么父级作用域会被一直引用着占据内存,从而形成内存泄漏<br>解决:  将父级函数指向null进行销毁或者将接收闭包函数的变量指向null进行销毁</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">function foo( param &#x3D; 1 )&#123;  return function()&#123;    return param +&#x3D; 1  &#125;&#125;let add &#x3D; foo()foo &#x3D; nulladd &#x3D; null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>如果父级作用域有着闭包函数不需要的变量该如何处理?<br>(1) 老版本的JS引擎会将不需要的变量也进行保留<br>(2) 新版本的JS引擎(V8)会将不需要的变量进行删除</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈JavaScript中的函数</title>
    <link href="/2022/04/12/JavaScript/jsBasic_05/"/>
    <url>/2022/04/12/JavaScript/jsBasic_05/</url>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>JavaScript中,函数是<font color="red"><strong>一等公民</strong></font>,可以作为一个<strong>参数传递</strong>,也可以作为一个<strong>函数的返回结果</strong></li></ol><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol><li>当一个函数的返回值是另一个函数或者接收的参数是另一个函数,这时候我们将这个函数称之为高阶函数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">funciton foo()&#123;  return function()&#123;&#125;&#125;function foo(callback)&#123; callback() &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="什么是函数-什么是方法"><a href="#什么是函数-什么是方法" class="headerlink" title="什么是函数?什么是方法?"></a>什么是函数?什么是方法?</h2><ol><li>函数就是一个单独的function,方法则是在某个对象里定义的function<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">函数:   function foo()&#123;&#125;方法:  const obj &#x3D; &#123;    foo:function()&#123;&#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2022/04/11/JavaScript/jsBasic_04/"/>
    <url>/2022/04/11/JavaScript/jsBasic_04/</url>
    
    <content type="html"><![CDATA[<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li><p>生命周期<br>(1) 分配申请所需要的内存<br>(2) 使用分配的内存(存放对象等)<br>(3) 不需要使用内存时,进行释放</p></li><li><p>JS分配内存<br>(1) 在声明变量时自动分配内存<br>(2) 基础数据类型和复杂(引用)数据类型内存的分配<br>   i. 基础数据类型存放在栈内存里<br>   ii.复杂数据类型会在内存中开辟一个空间,将数据存放在空间里并且返回这个空间的<font color="red"><strong>地址指针</strong></font>给变量进行引用</p></li><li><p>垃圾回收<br>定义: 因为内存大小是有限的,所以当内存不再需要的时候需要将其进行释放,用来减少内存空间的占用<br>   JS内置了垃圾回收机制:<font color="red"><strong>垃圾回收器(GC [Garbage Collection])</strong></font><br>   GC不是释放一个内存空间就销毁一次而是会在某个时间段内统计不需要的内存集中销毁</p></li><li><p>Q: 垃圾回收器如何去筛选不用的内存进行回收?<br>A: GC算法</p><ol><li>常见的GC算法<br><strong>引用计数</strong>: 声明一个变量,当任意其它变量引用了该变量,则会在<font color="red"><strong>retain count</strong></font>进行计数,当引用指针不指向该内存是,<font color="red"><strong>retain count</strong></font>就会进行相应数量的减少,当计数为0时就会被人为是垃圾进行回收<blockquote><p>弊端:容易造成循环引用,相互之间一直引用着,造成内存泄露</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">var obj1 &#x3D; &#123; name:&#39;nano&#39;,obj:obj2 &#125;var obj2 &#x3D; &#123; name:&#39;roily&#39;,obj:obj1 &#125;这样两个对象就一直在循环引用着对方当然可以直接 obj1 &#x3D; null 进行释放,但是如果忘记就会造成内存泄漏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p> <strong>标记算法[JS的主导GC算法]</strong>: 设置一个根对象(root object),垃圾回收器会定期从这个根开始,查找所有从根开始引用到的对象,对于那些没有引用的对象则会人为 是不可用对象,进行垃圾回收</p><blockquote><p>优势: 解决了对象之间的循环引用问题。如果从根开始查找标记一直到最后，无法查找到这几个对象在根线路中，那么这几个循环对象就会被视为不可用对象</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的编译和执行</title>
    <link href="/2022/04/11/JavaScript/jsBasic_03/"/>
    <url>/2022/04/11/JavaScript/jsBasic_03/</url>
    
    <content type="html"><![CDATA[<h2 id="全局函数的编译"><a href="#全局函数的编译" class="headerlink" title="全局函数的编译"></a>全局函数的编译</h2><ol><li>在js引擎编译的时候,如果检测到是一个函数:<br>(1) 会在Global Object先声明一个函数的变量<br>(2) 之后在内存中创建一个新的空间存储函数对象<br>(3) 函数对象里包含着(<strong>父级作用域、函数代码执行块和this</strong>),<font color="red"><strong>GO里的函数变量则引用着这个新地址</strong></font></li></ol><blockquote><p>注意: foo()是执行代码,编译时是不会执行的</p></blockquote><h2 id="函数的执行"><a href="#函数的执行" class="headerlink" title="函数的执行"></a>函数的执行</h2><ol><li>执行函数调用时( foo() ),会在全局调用栈中(GEC)<font color="red"><strong>创建一个函数执行上下文(FEC)</strong></font><br>(1) 函数执行上下文和全局执行上下文一样,也会创建一个内部变量VO,指向每个函数的<font color="red"><strong>AO[Activation Object](活跃对象)</strong></font><br>(2) AO相当于函数内的GO,与GO相同的逻辑,将函数里的形参和声明的变量存放在一个对象里<br>(3) 之后开始调用函数内的执行代码<br>(4) <strong>当函数调用完成后,执行改函数的FEC会从调用栈释放,同时在GO创建的函数内存也会被释放</strong></li></ol><blockquote><p>注意: <font color="red"><strong>函数的作用域跟它定义的位置有关系,跟它调用的位置没关系</strong></font><br>备注: 一个函数多次调用互相不受影响的原因就是因为每次GO在调用函数上下文执行栈时,都会创建一个新的AO存储函数里的形参和声明的变量/函数</p></blockquote><h2 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" class="headerlink" title="作用域链(scope chain)"></a>作用域链(scope chain)</h2><ol><li>Q:什么是作用域链?<br>A:<font color="red"><strong>scopechain = VO + ParentScope (VO和父级作用域)</strong></font><br>父级作用域在JS代码编译时就被确定了,就是函数地址中存放的parentscope<br>函数执行时,当定义的变量在VO中查找不到,会根据scope chain中的parent scope向上查找,直到全局作作用域</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li><p>ECMA最新标准中,将VO的概念重新解释为<font color="red"><strong>VE(Variable Environment)</strong></font>[环境变量],是将变量作为<font color="red"><strong>一条环境记录</strong></font>绑定在环境中,不一定非要是一个对象做数据集合(也可以是HashMap或其它)</p></li><li><p>JS在编译时,会将没用关键字声明的变量放到GO里</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">var a &#x3D; b &#x3D;10&#x2F;&#x2F; 解析为var a &#x3D; 10    b &#x3D; 10&#x2F;&#x2F; 先执行b的赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的运行</title>
    <link href="/2022/04/11/JavaScript/jsBasic_02/"/>
    <url>/2022/04/11/JavaScript/jsBasic_02/</url>
    
    <content type="html"><![CDATA[<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><ol><li>在JS引擎解析时,会形成一个<font color="red"><strong>Global Object(全局对象)</strong></font>,里面内置了<strong>String,Math等类,window:this(指向Global Object)</strong>,全局声明的变量在解析时也会放置在这里,但是默认值为undefined,因为解析时不执行代码(赋值、函数调用等)</li></ol><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><ol><li>JS引擎通过执行上下文栈（调用栈）调用代码</li><li>Q：全局变量没有调用栈该如何执行调用？<br>A：需要创建全局执行上下文（全局代码需要被执行时才会创建）（GEC）<br>   函数则是通过函数执行上下文进行调用（FEC）</li><li>全局执行上下文结构：<table><thead><tr><th>VO(Varibale[变量] Object):GO (Global Object)[VO就是GO]</th></tr></thead><tbody><tr><td>开始执行代码</td></tr><tr><td>通过VO在GO里寻找相应的变量和函数</td></tr></tbody></table></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础运行知识</title>
    <link href="/2022/04/10/JavaScript/jsBasic_01/"/>
    <url>/2022/04/10/JavaScript/jsBasic_01/</url>
    
    <content type="html"><![CDATA[<h2 id="JS代码是如何在浏览器中运行的"><a href="#JS代码是如何在浏览器中运行的" class="headerlink" title="JS代码是如何在浏览器中运行的?"></a>JS代码是如何在浏览器中运行的?</h2><ol><li>浏览器通过DNS解析域名为IP地址,访问IP地址返回html文件</li><li>html文件下载完成后,解析html文件<br>(1) 解析到script标签,就会去服务器下载对应的JS文件<br>(2) 遇到link标签,就会去服务器下载对应的css文件</li><li>等到js文件下载完成后,浏览器就会通过浏览器内核,解析运行JS代码</li></ol><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol><li>将html解析形成DOM树,此时遇到JS标签则会体质解析html,优先通过JS引擎加载和执行JS代码(这里可能会执行DOM操作),最后形成DOM结构树</li><li>将css层叠样式表解析成样式规则</li><li>将DOM树和样式规则组合形成渲染树(RenderTree)并且布局引擎(Layout)进行布局操作</li><li>绘制引擎(paint)将渲染树绘制并且展示在浏览器页面上</li></ol><blockquote><p><strong>注意:</strong> 在html被浏览器解析过程中,如果遇到了JS标签,则会停止解析html,优先加载和执行JS代码</p></blockquote><h2 id="JS引擎-V8引擎"><a href="#JS引擎-V8引擎" class="headerlink" title="JS引擎(V8引擎)"></a>JS引擎(V8引擎)</h2><ol><li><p>浏览器内核与JS引擎的关系</p><blockquote><p>浏览器内核<strong>包含</strong>JS引擎,JS引擎只负责解析和JS代码</p></blockquote></li><li><p>V8引擎工作原理<br>(1) 解析JS源代码(词法解析,语法解析)<br>(2) 解析后形成AST抽象语法树<br>(3) 通过Ignition库收集信息并编译成字节码,再把字节码编译成机器码执行运行结果</p></li><li><p>Q: 如果有一段JS代码频繁被使用,每次都把这部分代码转成字节码再编译成机器码会消耗很多性能,该如何解决?<br>A: Ignition库会将频繁调用的JS代码标记为<strong>hot</strong>,之后通过TurboFan库转换为优化后的机器码进行存储,下次再调用时直接调用存储的机器码运行</p></li><li><p>Q: 因为JS代码是弱类型语言,如果在一段频繁调用的JS代码使用逻辑运算时,更改了参数类型的值,导致计算方式不一致生成的机器码也不一致,该如何解决?<br>A: JS引擎会有逆优化(Deoptimization)的操作,反向转为字节码,再通过字节码转为机器码,当然这是一个比较消耗性能的操作<br>M: 这也是为什么在解析TypeScript转换的JS代码时效率更高的原因之一,TypeScript做了类型的强校验,省去了逆优化的操作</p></li><li><p>Q: JS引擎为什么先转为字节码,再转为机器码,而不是直接转为机器码?<br>A: 因为机器码比较占内存空间,字节码所占用的空间远远低于了机器码,总结就是<strong>牺牲时间来换取空间</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の一些踩坑点</title>
    <link href="/2022/03/04/miniProgram/basic-08/"/>
    <url>/2022/03/04/miniProgram/basic-08/</url>
    
    <content type="html"><![CDATA[<h2 id="WXS的使用"><a href="#WXS的使用" class="headerlink" title="WXS的使用"></a>WXS的使用</h2><ol><li>小程序如何使用在页面上使用类似于vue2的过滤器属性?<br>A: WXS</li><li>使用<ol><li>新建一个wxs文件,里面只支持js的es5语法,在里面写转换函数,通过module.exports = {方法名} 导出</li><li>在需要使用工具类函数的页面引入wxs标签<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; module 就是类似于整个模块名称,通过这个名称获取里面的方法&lt;wxs sr&#x3D;&quot;..&#x2F;文件.wxs&quot; module&#x3D;&quot;format&quot;&gt;&lt;&#x2F;wxs&gt;&lt;view&gt;&#123;&#123; format.moment(time) &#125;&#125;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>wx:for<ol><li>重命名item和index<br>Q:为什么要重命名?<br>A:当双重wx:for循环时必须得把内部wx:for循环的item和index做修改</li><li>示例:<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 通过 wx:for-item&#x2F;wx:for-index重命名 --&gt;  &lt;block wx:for&#x3D;&quot;&#123;&#123; arr &#125;&#125;&quot;&gt;    &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;&#x2F;view&gt;    &lt;view&gt; &#123;&#123;index&#125;&#125; &lt;&#x2F;view&gt;    &lt;!-- 通过 wx:for-item&#x2F;wx:for-index重命名 --&gt;    &lt;view wx:for&#x3D;&quot;&#123;&#123; arr2 &#125;&#125;&quot; wx:for-item&#x3D;&quot;itm&quot; wx:for-index&#x3D;&quot;ind&quot; &gt;        &#123;&#123; itm &#125;&#125;-&#123;&#123; ind &#125;&#125;    &lt;&#x2F;view&gt;  &lt;&#x2F;block&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li><li>wx:if/wx:elif/wx:else<ol><li>与hide区别<blockquote><p>就像v-if和v-show的区别,wx:if是对元素节点进行操作,hide是对样式操作</p></blockquote></li></ol></li></ol><p>  <strong>值的注意:</strong></p><blockquote><p>hide的默认值是true</p></blockquote><h2 id="wxss的背景图引用"><a href="#wxss的背景图引用" class="headerlink" title="wxss的背景图引用"></a>wxss的背景图引用</h2><blockquote><p>不能使用本地资源引用,只能引用在线地址或者把图片转成base64</p></blockquote><h2 id="npm包依赖安装关于基础库的bug"><a href="#npm包依赖安装关于基础库的bug" class="headerlink" title="npm包依赖安装关于基础库的bug"></a>npm包依赖安装关于基础库的bug</h2><blockquote><p>有些Npm依赖只支持特定的小程序基础库版本或者压根不支持小程序,所以在安装依赖的时候需要查看一下是否支持小程序</p></blockquote><h2 id="npm包构建流程"><a href="#npm包构建流程" class="headerlink" title="npm包构建流程"></a>npm包构建流程</h2><ol><li>初始化项目包的npm<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm init --y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li>npm安装对应依赖包</li><li>详情 -&gt; 勾选使用npm模块选项 </li><li>点击菜单栏 : 工具 -&gt; 构建npm (每次下载新的依赖都得重新构建)</li><li>通过require或者import方法引用模块<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const moment &#x3D; require(&#39;moment&#39;)const value &#x3D; moment(+new Date()).format(&#39;YYYY-MM-DD&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>构建后再project.config.json文件中进行配置<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;   &quot;setting&quot;: &#123;       &quot;packNpmManually&quot;: true,       &quot;packNpmRelationList&quot;: [        &#123;             &quot;packageJsonPath&quot;: &quot;.&#x2F;package.json&quot;,             &quot;miniprogramNpmDistDir&quot;: &quot;.&#x2F;&quot;         &#125;       ]   &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p><strong>注意：</strong> </p><blockquote><p>由于目前新版开发者工具创建的小程序目录文件结构问题，npm构建的文件目录为miniprogram_npm，并且开发工具会默认在当前目录下创建miniprogram_npm的文件名，所以新版本的miniprogramNpmDistDir配置为’./‘即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の登录流程</title>
    <link href="/2022/03/04/miniProgram/basic-07/"/>
    <url>/2022/03/04/miniProgram/basic-07/</url>
    
    <content type="html"><![CDATA[<h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">    小程序端:         (1) 在小程序通过wx.login API获取临时的code        (2) 调用接口将code传递给自己的服务器    自己服务器端:        (1) 获取小程序内传来的临时的code        (2) 将临时的code + appId + appsecret发送给微信小程序服务器,获取 openId 和 session_key [这个时候用户不知道自己已经登录成功]        (3) 自己服务器内将 openId和session_key 组合生成有期限的token,返回给小程序端    小程序端:        (1) 获取自己服务器端内传递的token,并存储到storeage中        (2) 将需要记录用户操作的接口中携带这个token发送给自己的服务器端        自己服务器端:        (1) 将接口传递的token进行解析,解析出openId和session_key,将操作保存在数据库内,避免向微信服务器多次请求获取openId        如果用户更换手机?        (1) 判断storage中是否存储了token,如果未存储则重复登录流程        (2) 如果存储了token,判断是否已经过期,如果过期了则重新登录,如果没有过期,继续判断session_key是否过期,如果没有过期,则继续使用这个token进行用户校验,反之则重新登录判断session_key是否过期:wx.checkSession(&#123;      success: (res) &#x3D;&gt; &#123;        resolve(true)      &#125;,      fail: () &#x3D;&gt; &#123;        reject(false)      &#125;    &#125;)  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol><li>什么是openId?<blockquote><p>openId 用户身份的唯一标识,用openId去识别用户 [unionId用于第三方登录]</p></blockquote></li><li>什么是unionId?<blockquote><p>unionId也是唯一的标识,用于多平台(APP,公众号,网页)授权时进行标识识别,多个产品源进行数据共享<br> 多平台共享时需要同时绑定手机号(常用),因为可能某个平台不支持微信的登录,需要通过其它的方式进行信息绑定(最多的就是手机号)<br> 所以有些客户端在要求你微信登录之后需要绑定手机号</p></blockquote></li></ol><p>注意: 服务器端openID和unionID都是可以获取的,如果涉及到多端的数据共享,建议直接使用unionID进行校验</p><h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><ol><li>使用getUserProfile API<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">wx.getUserProfile(&#123;  desc: &#39;desc&#39;, &#x2F;&#x2F; 必填  success:(res)&#x3D;&gt;&#123;    console.log(res);    &#x2F;&#x2F; 成功回调  &#125;,  fail:()&#x3D;&gt;&#123;&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p><strong>值得注意:</strong></p><blockquote><p>不允许直接在生命周期方法里获取用户信息,只能通过事件触发获取<br>示例:<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这里加不加open-type 也可以&lt;button bindtap&#x3D;&quot;getUserProfile&quot; open-type&#x3D;&quot;getUserInfo&quot;&gt;&lt;&#x2F;button&gt;getUserProfile()&#123;  wx.getUserProfile(&#123;      desc: &#39;你好&#39;, &#x2F;&#x2F; 必填      success:(userInfo)&#x3D;&gt;&#123;      &#x2F;&#x2F; 这里获取用户信息          console.log(userInfo);         &#125;,      fail:()&#x3D;&gt;&#123;&#125;  &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p></blockquote><h2 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h2><ol><li>获取手机号<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;button open-type&#x3D;&quot;getPhoneNumber&quot;&gt;获取手机号&lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol><p>  <strong>值得注意:</strong><br>  目前不能直接获取手机号,再调用这个button按钮时会传递一个code,将code传递给自己服务器端的一个接口,接口内部再访问微信的服务器,通过这个code获取手机号码信息</p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の分包</title>
    <link href="/2022/03/04/miniProgram/basic-06/"/>
    <url>/2022/03/04/miniProgram/basic-06/</url>
    
    <content type="html"><![CDATA[<h2 id="使用场景-amp-限制"><a href="#使用场景-amp-限制" class="headerlink" title="使用场景&amp;限制"></a>使用场景&amp;限制</h2><ol><li>优化小程序启动时加载事件,协同开发进行解耦</li><li>限制:<br>(1) <strong>tabbar或者首屏使用的文件不能进行分包</strong><br>(2) 单个小程序打包大小不能超过2MB,使用分包总体小程序包体积不能大于20MB</li></ol><p>  <strong>值得注意:</strong></p><blockquote><p>如果需要分包,应该在小程序开发前期就规划好,定下基础模块,防止往后开发改造目录结构带来麻烦</p></blockquote><h2 id="使用分包"><a href="#使用分包" class="headerlink" title="使用分包"></a>使用分包</h2><ol><li><p>在根目录下简历packageModeName(模块名称)的文件夹</p><blockquote><p>每个文件夹其实都是一个小程序开发目录,可以在里面定义assets,pages等等(app.js这些不需要配置)<br><img src="/img/wx-%E5%88%86%E5%8C%85.png" alt="小程序分包目录结构"></p></blockquote></li><li><p>配置路由</p><blockquote><p>分包后,将app.json文件中分包的文件路由进行相应的删除<br>将微信路由跳转api的路径也进行相应的更改<br>url: ‘/分包模块名称/pages/….’</p></blockquote></li><li><p>subPackage配置(分包配置属性)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">app.json文件配置分包属性&quot;subPackages&quot;: [    &#x2F;&#x2F; 配置分包属性    &#123;        &quot;root&quot;:&quot;packageDetail&quot;,  &#x2F;&#x2F; 分包根目录名称(分包模块名称)        &quot;name&quot;:&quot;pDetail&quot;,        &#x2F;&#x2F; 分包根目录别名,可以不写        &quot;pages&quot;:[                &#x2F;&#x2F; 分包路由配置            &quot;pages&#x2F;detail-search&#x2F;index&quot;,            &quot;pages&#x2F;detail-songs&#x2F;index&quot;,            &quot;pages&#x2F;detail-video&#x2F;index&quot;        ]    &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h2><blockquote><p> 定义: 所有功能(组件依赖,方法依赖)完全不依赖于主包,独立存在的一个包文件<br> 使用场景: 扫描二维码<br> 使用: 在分包配置的对象中设置”independent” : true 属性<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&quot;subPackage&quot;:[  &#123;    &quot;root&quot;: &quot;包模块根目录名称&quot;,    &quot;name&quot;: &quot;包模块别名&quot;,    &quot;pages&quot;:[ ],   &#x2F;&#x2F; 页面路由    &quot;independent&quot; : true &#x2F;&#x2F; 独立分包 属性  &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><br>  <strong>值得注意:</strong><br>      (1) 独立分包时,app.wxss对独立分包的页面不起到作用<br>      (2) 独立分包完全不能依赖主包,相当于做一个独立的页面嵌进应用内<br>      (3) App只能在主包定义,独立分包不行(可以使用getApp方法,如果主包没有下载下来,则获取不到值)<br>      (4) 独立分包不支持插件</p></blockquote><h2 id="分包预下载"><a href="#分包预下载" class="headerlink" title="分包预下载"></a>分包预下载</h2><blockquote><p>定义: 类似于懒加载,优先把主包加载完成,之后在闲置时下载设置预下载的分包<br>使用: 设置<code>preloadRule</code>属性<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&quot;preloadRule&quot;:&#123;  &quot;需要分包预下载的页面路径&quot;:&#123;      &quot;newwork&quot;: &quot;wifi&#x2F;all&quot;, &#x2F;&#x2F; 设置在哪个网络环境下可以预下载    &quot; packages&quot;:[ root, name ] &#x2F;&#x2F; 设置预下载的包名,使用root&#x2F;name  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の数据共享</title>
    <link href="/2022/03/04/miniProgram/basic-05/"/>
    <url>/2022/03/04/miniProgram/basic-05/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>小程序目前没有像vue一样有一个契合性很好的全局状态管理库并且现有的全局状态共享并不是响应式的,但是可以下载相应的依赖包进行全局状态管理并且达到响应式的效果。这篇博文就是介绍一个比较不错的全局状态管理库和小程序本身全局共享数据的特点。</p></blockquote><h2 id="app-js全局共享数据"><a href="#app-js全局共享数据" class="headerlink" title="app.js全局共享数据"></a>app.js全局共享数据</h2><ol><li>在app.js中 声明变量 globalData</li><li>通过getApp( ) 获取app.js对象</li><li>getApp().globalData 获取共享变量<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">App(&#123;  globalData:&#123;    num : 1  &#125;&#125;)&#x2F;&#x2F; page页面(组件页面也是一样的用法)const app &#x3D; getApp()Page(&#123;  useGlobalData()&#123;    console.log( app.globalData ) --&gt; &#123; num:1 &#125;  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <strong>值的注意:</strong></p><blockquote><p>在app里共享的数据不是响应式的</p></blockquote><h2 id="module-模块-引入"><a href="#module-模块-引入" class="headerlink" title="module(模块)引入"></a>module(模块)引入</h2><ol><li>通过es6的模块化语法将数据封装在一个js文件,之后在需要的页面中引入</li></ol><p>  <strong>缺点:</strong> </p><blockquote><p>数据也不是响应式的</p></blockquote><h2 id="hy-event-store-依赖包"><a href="#hy-event-store-依赖包" class="headerlink" title="hy-event-store(依赖包)"></a>hy-event-store(依赖包)</h2><blockquote><p>定义: 是coderWhy老师开发的一个全局状态管理的开发库,语法风格类似于vuex,使用比较便捷,体积也比较小。<br>地址: <a href="https://github.com/coderwhy/hy-event-store">https://github.com/coderwhy/hy-event-store</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の异步api封装&amp;插槽/混入</title>
    <link href="/2022/03/04/miniProgram/basic-04/"/>
    <url>/2022/03/04/miniProgram/basic-04/</url>
    
    <content type="html"><![CDATA[<h3 id="异步API的封装"><a href="#异步API的封装" class="headerlink" title="异步API的封装"></a>异步API的封装</h3><ol><li>为什么要封装微信的异步API?<ol><li>因为异步的原因,可能会与我们代码逻辑有所冲突</li><li>因为微信提供的异步API很繁琐,我们通过你自己的进一步封装,可以更好的调用,减少代码的体积</li></ol></li><li>如何封装?<ol><li>使用<code>promise</code>封装</li><li>示例:<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 我们这里使用微信提供的请求API进行演示,封装逻辑都是一样的const baseUrl &#x3D; &#39;xxx&#39;const request &#x3D; (params,token) &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    wx.request(&#123;      ...params,      url: params.baseUrl ? params.baseUrl + params.url : baseUrl + params.url,      success: (result) &#x3D;&gt; &#123;        &#x2F;&#x2F; 注意: resolve只能传递一个参数,多个参数可以使用对象传递        resolve(result.data)      &#125;,      &#x2F;&#x2F; 因为fail这里一定返回的是错误信息并reject也是一个方法的调用,所以这里可以简写      fail: reject,      complete: (res) &#x3D;&gt; &#123;&#125;,    &#125;)  &#125;)&#125;export default request<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><p>  <strong>这样,我们在其它js文件引入后,可以进行async await的解析或者promise链式调用</strong></p><h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot(插槽)"></a>slot(插槽)</h2><ol><li><p>slot 用法和vue的默认插槽一样(也有具名插槽)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 使用:&#x2F;&#x2F;子组件&lt;view&gt;  &lt;slot name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;view&gt;Component(&#123;  options: &#123;    &#x2F;&#x2F; 设置属性开启具名插槽    multipleSlots: true  &#125;&#125;)&#x2F;&#x2F; 父组件中&lt;component&gt;  &lt;view slot&#x3D;&quot;name&quot;&gt;&lt;&#x2F;view&gt;&lt;&#x2F;component&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>如何在封装包含插槽的组件时,如果不传递传参默认展示其它内容?</p><ol><li><p>通过传递属性控制(不推荐)<br>这里就不做展示了,因为比较容易想到思路且代码比较冗余</p></li><li><p>法1:通过css</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">wxml中:  &lt;view class&#x3D;&quot;slot-wrapper&quot;&gt;    &lt;view class&#x3D;&quot;slot&quot; &gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;view&gt;     &lt;view clas&#x3D;&quot;default&quot; &gt; 展示默认内容 &lt;&#x2F;view&gt;  &lt;&#x2F;view&gt;wxss中:  &#x2F;&#x2F; 思路: 通过非空选择器判断元素是否存在之后兄弟选择器进行配置显隐  &#x2F;&#x2F; 注意: 兄弟选择器只能选择同级下方的属性,所以要注意dom结构  .slot-wrapper .slot:empty+.default&#123;    display: flex;  &#125;   .slot-wrapper .slot&#123;     display: none;     justify-content:center;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h2 id="behaviors-混入"><a href="#behaviors-混入" class="headerlink" title="behaviors(混入)"></a>behaviors(混入)</h2><ol><li>用法类似于vue的Mixin<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const behaviorsOne &#x3D; require(&#39;behaviorsOne&#39;)Component(&#123;   behaviors:[ behaviorsOne ]&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <strong>值得注意:</strong><br>    (1) 这是组件专有的属性<br>    (2) 如果组件中有同名变量,组件中的变量会覆盖behaviors里的变量,如果变量是引用类型,则会进行合并<br>    (3) behaviors里的生命周期快于组件里的生命周期,如果一个behaviors文件被一个组件引用多次,那么只会执行一次该生命周期函数</p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の页面App生命周期&amp;路由传参</title>
    <link href="/2022/03/04/miniProgram/basic-03/"/>
    <url>/2022/03/04/miniProgram/basic-03/</url>
    
    <content type="html"><![CDATA[<h2 id="App生命周期"><a href="#App生命周期" class="headerlink" title="App生命周期"></a>App生命周期</h2><table><thead><tr><th>属性</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>onLaunch</td><td>监听小程序初始化</td><td>应用第一次启动就会触发的事件(一般用做程序启动获取用户的个人信息)[比onShow先触发]</td></tr><tr><td>onShow</td><td>监听小程序启动或切前台</td><td>应用被用户看到时触发,比onLaunch慢,会频繁触发[重置应用的数据和页面效果]</td></tr><tr><td>onHide</td><td>监听小程序切后台</td><td>应用被隐藏[暂停或清除定时器,减少内存]</td></tr><tr><td>onError</td><td>错误监听函数</td><td>应用代码发生报错会触[收集用户的错误信息,通过异步请求将错误的信息发送到后台]</td></tr><tr><td>onPageNotFound</td><td>页面不存在监听函数</td><td>应用第一次启动的时候,如果找不到第一个入口页面,才会触发[如果首页找不到了,重新跳到第二个首页]</td></tr></tbody></table><h2 id="Page生命周期"><a href="#Page生命周期" class="headerlink" title="Page生命周期"></a>Page生命周期</h2><table><thead><tr><th>属性</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>onLoad</td><td>监听页面加载</td><td>发送异步请求来初始化页面数据(页面加载时第一个调用)</td></tr><tr><td>onShow</td><td>监听页面显示</td><td>页面加载时第二个调用</td></tr><tr><td>onReady</td><td>监听页面初次渲染完成</td><td>页面加载时第三个调用</td></tr><tr><td>onHide</td><td>监听页面隐藏</td><td></td></tr><tr><td>onUnload</td><td>监听页面卸载</td><td></td></tr><tr><td>onPullDownRefresh</td><td>监听用户下拉动作</td><td>页面数据和样式初始化,需要配置 “enablePullDownRefresh”: true</td></tr><tr><td>onReachBottom</td><td>页面上拉触底事件的处理函数</td><td>上拉加载下一页数据</td></tr><tr><td>onShareAppMessage</td><td>用户点击右上角转发</td><td></td></tr><tr><td>onPageScroll</td><td>页面滚动触发事件的处理函数</td><td>小程序横屏竖屏切换时触发 [需要在json文件中配置 “pageOrientation”:”auto”]开启横竖屏切换</td></tr><tr><td>onResize</td><td>页面尺寸改变时触发</td><td></td></tr><tr><td>onTabItemTap</td><td>当前是tab页,点击tab时触发</td><td></td></tr></tbody></table><h2 id="路由传参和参数获取"><a href="#路由传参和参数获取" class="headerlink" title="路由传参和参数获取"></a>路由传参和参数获取</h2><p>  场景: 微信小程序的路由跳转方式分为两种: 1) 组件跳转 2) API跳转</p><ol><li><p>组件跳转时传参</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过拼接url参数进行组件传参 target-&gt; 在小程序内跳转&#x2F;&#x2F; 注意点: 不能通过es6的模板字符串进行拼接,tabBar跳转无法传递参数&lt;navigator target&#x3D;&quot;self&quot; url&#x3D;&#39;&#x2F;packagePlayer&#x2F;pages&#x2F;music-player&#x2F;index?id&#x3D;&#123;&#123;id&#125;&#125;&#39; &gt;&lt;&#x2F;navigator&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p>API跳转</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;button catchtap&#x3D;&quot;onJumpUrl&quot;&gt;跳转&lt;&#x2F;button&gt;Page(&#123;  onJumpUrl(e)&#123;    &#x2F;&#x2F; API调用因为是写在js里的,可以使用ES6的模板字符串    wx.navigateTo(&#123;      url: &#96;&#x2F;packagePlayer&#x2F;pages&#x2F;music-player&#x2F;index?id&#x3D;$&#123;this.data.id&#125;&#96;,    &#125;);  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <strong>注意</strong>: 微信小程序是多种路由跳转方式的,但是传参基本一致,这里为了演示如何拼接参数只使用了部分API(组件跳转可以在<code>open-type</code>中设置跳转属性)</p><ol start="3"><li>路由参数获取<ol><li><p>生命周期获取<br>定义: 在Page的onLoad生命周期可以通过options参数获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Page(&#123;  onLoad(options)&#123;    const &#123; id &#125; &#x3D; options  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>API获取</p><div class="code-wrapper"><pre><code>let pages = getCurrentPages();     // 获取跳转页面的信息数组let currentPages = pages[pages.length - 1]    // 每次都取上一个页面的信息let options = currentPages.options    // 通过options里获取参数const &#123; goods_id &#125; = optionsthis.getGoodsDetails(goods_id)</code></pre></div></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の组件使用</title>
    <link href="/2022/03/03/miniProgram/basic-02/"/>
    <url>/2022/03/03/miniProgram/basic-02/</url>
    
    <content type="html"><![CDATA[<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><ol><li><p>注册自定义组件</p><ol><li>在微信开发者工具中,选择components文件夹鼠标右击选择新建component,输入名称后自动创建4个文件,基本与page页面结构相同</li><li>在需要使用组件的页面文件或者组件文件,选择.json结尾的配置文件</li><li>在json文件中的”usingCompoents”属性中进行配置<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;usingComponents&quot;: &quot;需要引入的组件路径&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol></li><li><p>使用第三方组件库(vantUI)<br>详情见: <a href="https://vant-contrib.gitee.io/vant-weapp/#/quickstart">https://vant-contrib.gitee.io/vant-weapp/#/quickstart</a></p></li></ol><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><ol><li><p>父组件通信子组件</p>   <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">父组件中:   &lt;child-comp value&#x3D;&quot;&#123;&#123; num &#125;&#125;&quot;&gt;&lt;&#x2F;child-comp&gt;  Page(&#123;    data:&#123;      num: 1    &#125;  &#125;)子组件中:  &lt;view&gt; &#123;&#123; value &#125;&#125; &lt;&#x2F;view&gt;  --&gt; 显示为1  Component(&#123;    properties:&#123;      value:&#123;       type: Number,       value: 0      &#125;    &#125;,    lifetimes:&#123;      ready()&#123;       console.log(  this.properties.value ) --&gt; 0      &#125;    &#125;  &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>   <strong>注意</strong>: </p><div class="code-wrapper"><pre><code> (1) 也可以通过子组件的data获取在properties定义的值,因为在子组件接收父组件传递的参数后,data会拷贝一份properties的值,但是不推荐使用data里的值,容易造成代码混淆 (2) 不能直接使用setData去修改propertie中定义的参数,必须使用子组件通信父组件的方式改变值</code></pre></div></li><li><p>子组件通信父组件</p>   <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">父组件中:    &#x2F;&#x2F; 首先绑定自定义事件用来接收子组件传递的参数    &lt;view bindgetChildValue&#x3D;&quot;getValue&quot;&gt;&lt;&#x2F;view&gt;    Page(&#123;      getValue(e)&#123;        &#x2F;&#x2F; 在e.detail中接收子组件传递的参数,key名为value        console.log(e.detail.value)      &#125;    &#125;)子组件中:  &#x2F;&#x2F; 使用全局定义的方法 this.triggleEvent(&#39;父组件自定义事件名称&#39;, 子组件需要传递的参数)  &lt;button catchtap&#x3D;&quot;passValue&quot; data-item&#x3D;&quot;2&quot; &gt;点击传参&lt;&#x2F;button&gt;  Component(&#123;    data:&#123;      num : 2    &#125;,    methods:&#123;      passValue(e)&#123;        const &#123; item &#125; &#x3D; e.currentTarget.dataset        this.triggerEvent(&#39;getChildValue&#39;,&#123; num:this.data.num ,item  &#125;)      &#125;    &#125;  &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><ol><li><p><strong>组件的生命周期最好定义在lifetimes属性中</strong></p>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Component(&#123;  lifetimes:&#123;    ready()&#123;&#125;  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>组件生命周期</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>created</td><td>组件刚刚被创建,不能使用setData</td></tr><tr><td>attached</td><td>组件实例进入页面节点树执行</td></tr><tr><td>ready（常用）</td><td>组件布局完成后执行</td></tr><tr><td>moved</td><td>组件实例被移动到节点树另一个位置时执行</td></tr><tr><td>detached</td><td>组件实例被从页面节点树移除时执行</td></tr></tbody></table></li></ol><h2 id="observers-监听属性"><a href="#observers-监听属性" class="headerlink" title="observers(监听属性)"></a>observers(监听属性)</h2><ol><li>定义:<br>小程序组件独有的属性。数据监听器支持监听属性(properties)或内部数据(data)的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。</li><li>使用: <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">(1) 对象&#x2F;数组单层监听  data:&#123;    arr:[1,2,3]    obj:&#123; a:1 , b:2&#125;  &#125;,  observers:&#123;    &#39;arr[1]&#39;(newval)&#123;&#125;,    &#39;obj.a&#39;(newval)&#123;&#125;  &#125;(2) 多个变量同时监听  data:&#123;    num1: 1,    num2: 2,    sum:0  &#125;  observers:&#123;    &#39;num1,num2&#39;(numbers1,numbers2)&#123;      this.setData(&#123;        sum &#x3D; numbers1 + numbers2      &#125;)    &#125;  &#125; (3) 监听所有子数据的变量变化 定义: 通过通配符** data:&#123;    obj:&#123;       child:&#123;          a:1,                          b:2      &#125;    &#125;  &#125;,  observers:&#123;    &#39;obj.child.**&#39;(newval)&#123;      newval &#x3D;&#x3D;&#x3D; this.data.obj.child    &#125;  &#125; (4) 可以直接监听**,即监听所有数据的变化  observers:&#123;    &#39;**&#39;(newval)&#123;      &#x2F;&#x2F; newval &#x3D; &#123;...this.data,...this.properties&#125;    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の基础语法</title>
    <link href="/2022/03/03/miniProgram/basic-01/"/>
    <url>/2022/03/03/miniProgram/basic-01/</url>
    
    <content type="html"><![CDATA[<h2 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h2><ol><li>初识微信小程序插值语法<br>定义: 类似于vue的插值语法,也采用<code>&#123;&#123; &#125;&#125;</code>进行值的动态绑定<br>值的注意:  <div class="code-wrapper"><pre><code> (1) 无法像vue语法中可以进行函数调用 (2) 传递布尔值值必须使用&#123;&#123;&#125;&#125;传递,不使用&#123;&#123;&#125;&#125;默认都是字符串,false就会被编译成字符串false,显示为true</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;view&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;view&gt; --&gt; 页面显示: Nano&lt;view&gt;&#123;&#123;change(name)&#125;&#125;&lt;&#x2F;view&gt; --&gt; 页面无法显示Page(&#123;  data:&#123;    name : &#39;Nano&#39;  &#125;,  change()&#123;&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>动态值的绑定<br>定义: 用于在样式、微信指令和传参时值的动态绑定<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1) 样式的绑定   class:      &lt;view class&#x3D;&quot;bg-color &#123;&#123; isShow ?&#39;ft-color&#39;:&#39;&#39; &#125;&#125;&quot;&gt;&lt;&#x2F;view&gt;   style:      &lt;view style&#x3D;&quot;padding-top:&#123;&#123; pdTop &#125;&#125;px&quot;&gt;&lt;&#x2F;view&gt;          Page(&#123;      data:&#123;        isShow : true ,        pdTop :36      &#125;    &#125;)2) 微信指令的参数绑定    wx:if&#x2F;wx:elif&#x2F;wx:else&#x2F;wx:for :      &lt;view wx:if&#x3D;&quot;&#123;&#123; item &#x3D;&#x3D;&#x3D; 1&#125;&#125;&quot;&gt;1&lt;&#x2F;view&gt;      &lt;view wx:elif&#x3D;&quot;&#123;&#123; item &#x3D;&#x3D;&#x3D; 2&#125;&#125;&quot;&gt;2&lt;&#x2F;view&gt;      &lt;view wx:else&gt;3&lt;&#x2F;view&gt;      &lt;view wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; :key&#x3D;&quot;ind&quot; wx:for-item&#x3D;&quot;itm&quot; wx:for-index&#x3D;&quot;ind&quot;&gt;&#123;&#123; itm &#125;&#125;&lt;&#x2F;view&gt;      Page(&#123;        data:&#123;          item : 1 ,          arr : [1, 2, 3]        &#125;      &#125;)3) 组件动态传参   父组件:    &lt;Child item&#x3D;&quot;&#123;&#123; type &#125;&#125;&quot;&gt;&lt;&#x2F;Child&gt;    Page(&#123;      data:&#123;        type : 1      &#125;    &#125;)   json文件:      &quot;usingComponents&quot; : &#123;        &quot;Child&quot; : 路径      &#125;   子组件:    &lt;view&gt; &#123;&#123; type &#125;&#125; &lt;&#x2F;view&gt;    Component(&#123;      properties:&#123;        type: Number,        value: 0      &#125;    &#125;)4) 配合方法传参:   前言: 配合方法动态传参一般在wx:for循环时出现比较多   &lt;block wx:for&#x3D;&quot;&#123;&#123; row &#125;&#125;&quot; wx:key&#x3D;&quot;index&quot; wx:for-item&#x3D;&quot;item&quot;&gt;      &lt;button catchtap&#x3D;&quot;handlePassRow&quot; data-row&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;打印数据&lt;&#x2F;button&gt;   &lt;&#x2F;block&gt;   Page(&#123;     data:&#123;       row:[         &#123; index:1 &#125;       ]     &#125;,     handlePassRow(e)&#123;       &#x2F;&#x2F; 小程序固定语法,从e.currentTarget.dataset 获取       const &#123; row &#125; &#x3D; e.currentTarget.dataset       console.log( row )  --&gt; &#123; index: 1 &#125;     &#125;   &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="事件绑定语法"><a href="#事件绑定语法" class="headerlink" title="事件绑定语法"></a>事件绑定语法</h2><ol><li>小程序的方法绑定分为 bind 和catch<ol><li>区别:<br>前言: 在小程序中,不支持通过js原生的<code>e.stopProgaration</code>进行阻止事件冒泡<br><strong>bind无法阻止事件冒泡,而catch可以</strong></li><li>绑定示例:<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; bind&#x2F;catch:tap 和 bind&#x2F;catchtap 性质是一样的  &lt;button bind:tap&#x3D;&quot;tapClick&quot;&gt; bind点击事件 &lt;button&gt;&lt;button catch:tap&#x3D;&quot;catchClick&quot;&gt; catch点击事件 &lt;button&gt;&#x2F;&#x2F; 用于子组件与父组件通信使用&lt;button bindselfAtion&#x3D;&quot;selfAction&quot;&gt; 绑定自定义事件点击 &lt;button&gt;&#x2F;&#x2F; 在page页面和component中方法存放的位置略有不同page: 与data平级  data:&#123;&#125;,  tapClick(e)&#123;&#125;component: 存放在methods中  data:&#123;&#125;  methods:&#123;    tapClick(e)&#123;&#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h2 id="事件event参数和setData"><a href="#事件event参数和setData" class="headerlink" title="事件event参数和setData()"></a>事件event参数和setData()</h2><ol><li><p>小程序通过bind/catch绑定的语法都通过event参数获取需要事件信息,类似于原生事件的event参数</p><ol><li><p>如何获取传递的参数?<br>表单元素获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;input bindinput&#x3D;&quot;onInput&quot; &#x2F;&gt;Page(&#123;  &#x2F;&#x2F; 表单元素获取是在e.currentTarget.detail中获取,固定key值为value  onInput(e)&#123;     const &#123; value &#125; &#x3D; e.currentTarget.detail  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>非表单元素获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;view bindtap&#x3D;&quot;onClick&quot; data-item&#x3D;&quot;1&quot;&gt;&lt;&#x2F;view&gt;Page(&#123;  &#x2F;&#x2F; 表单元素获取是在e.currentTarget.dataset中获取,固定key值为data-后面绑定的key值  onClick(e)&#123;     const &#123; item &#125; &#x3D; e.currentTarget.dataset --&gt; 1  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>值的注意:<br>  <strong>当子组件与父组件进行传参通信时,是通过e.currentTarget.detail获取的参数</strong>,也就是说dataset存储的一般都是自定义绑定的参数值,而detail里传递的参数是表单值或者子组件通信传递来的值</p></li></ol></li><li><p>e.currentTarget和e.target的区别<br> e.currentTarget 指向的是触发事件监听的对象<br> e.target 指向的是添加（注册）监听事件的对象<br> 如果没有发生元素嵌套,那么 e.currentTarget和e.target是一样的<br> <strong>一般我们在小程序里,一般都采用e.currentTarget防止不可控的错误发生</strong></p></li><li><p>setData()<br>定义: setData()是用来响应式更新页面绑定的data中的值的内置共用方法<br>执行时机:<br>   在执行赋值操作时是同步的<br>   在执行页面渲染时是异步的</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;view&gt; &#123;&#123; num &#125;&#125; &lt;&#x2F;view&gt;&lt;button catchtap&#x3D;&quot;onAdd&quot;&gt; add &lt;&#x2F;button&gt;Page(&#123;  data:&#123;    num:0  &#125;,  onAdd(e)&#123;    let num &#x3D; this.data.num++    this.setData(&#123;      num    &#125;)  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置Valine评论系统</title>
    <link href="/2021/12/15/hexo/hexoComment/"/>
    <url>/2021/12/15/hexo/hexoComment/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="code-wrapper"><pre><code>本文主要用来介绍如何在Fluid主题中博客添加Valine评论系统</code></pre></div><h3 id="Valine优点"><a href="#Valine优点" class="headerlink" title="Valine优点"></a>Valine优点</h3><p>其实Fluid主题内置了很多评论插件,比如<code>utterances</code>,<code>valine</code>等等,选择valine的原因如下:</p><ul><li><p>无后端实现</p></li><li><p>高速，使用国内后端云服务提供商 LeanCloud 提供的存储服务</p></li><li><p>开源，自定义程度高</p></li><li><p>支持邮件通知</p></li><li><p>支持验证码</p></li><li><p>支持 Markdown</p></li></ul><h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><ol><li>注册Leancloud</li></ol><p>Valine作为一款第三方的评论系统，评论数据都储存在Leancloud上，所以第一步我们要去 leancloud官网：<a href="https://www.leancloud.cn/">https://www.leancloud.cn/</a> 注册一个账户，注册完成后现在需要实名认证后才可以创建应用<br><img src="/img/fluid-comment.png" alt="注册并实名Leancloud账号" title="注册并实名Leancloud账号"><br>2. 创建应用</p><p><img src="/img/fluid-comment-2.png" alt="创建应用" title="创建应用"></p><p><img src="/img/fluid-comment-3.png" alt="创建应用" title="创建应用"></p><ol start="3"><li>配置应用</li></ol><p><img src="/img/fluid-comment-4.png" alt="配置应用" title="配置应用"></p><p><img src="/img/fluid-comment-5.png" alt="配置应用" title="配置应用"></p><p><img src="/img/fluid-comment-6.png" alt="配置应用" title="配置应用"></p><ol start="4"><li><p>配置_config.fluid.yml</p><ol><li><p>在文件中查找<code>Comments</code>关键字,进行下面配置</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 评论插件# Comment plugincomments:    enable: true    # 指定的插件，需要同时设置对应插件的必要参数    # The specified plugin needs to set the necessary parameters at the same time    # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis    type: valine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>在文件中查找<code>valine</code>关键字,进行下面配置</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">valine:appId: 填写刚才在Leancloud创建的应用的appIdappKey: 填写刚才在Leancloud创建的应用的appKeypath: window.location.pathname # 当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表placeholder:  吐槽一哈!!!! # 占位符avatar: &#39;retro&#39; # Gravatar 头像展示方式meta: [&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]  # 评论者相关属性requiredFields: []pageSize: 10 # 评论列表分页，每页条数lang: &#39;zh-CN&#39; # zh-CN | zh-TW | en | jahighlight: false # 代码是否高亮recordIP: false # 是否记录评论者IPserverURLs: &#39;&#39; # REST API 服务器地址，国际版不填emojiCDN:emojiMaps:enableQQ: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h3 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h3><div class="code-wrapper"><pre><code>配置完成之后重启hexo,就可以看到效果~</code></pre></div><p><img src="/img/fluid-comment-7.png" alt="完成配置" title="完成配置"></p><h3 id="删除评论数据"><a href="#删除评论数据" class="headerlink" title="删除评论数据"></a>删除评论数据</h3><p><img src="/img/fluid-comment-8.png" alt="删除评论数据" title="删除评论数据"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>hexo主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置</title>
    <link href="/2021/12/15/hexo/fluidOptions/"/>
    <url>/2021/12/15/hexo/fluidOptions/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="code-wrapper"><pre><code>之前介绍了如何使用Fluid的主题,这篇将继续深入如何去使用Fluid。</code></pre></div><h3 id="基础目录结构"><a href="#基础目录结构" class="headerlink" title="基础目录结构"></a>基础目录结构</h3><ol><li>使用<code>hexo n 文件名称</code>创建一个md文档,用来创作博客文章,进入md文档后,基础结构展示如下: <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">---title: 使用Hexo搭建博客（基础版） # 博客文章标题date: 2021-12-15 01:47:44  # 文章编写日期index_img: &#x2F;img&#x2F;fluid-hexo.png # 缩略图categories:- hexo博客搭建 # 分类tags: # 标签- hexo- github---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h3 id="常用基础配置"><a href="#常用基础配置" class="headerlink" title="常用基础配置"></a>常用基础配置</h3><p>Flui主题自身内置了很多插件,当我们想美化自己的博客时,可以在<code>_config.fluid.yml</code>文件下,通过一些配置去实现,非常的简便。接下来就介绍一些常用配置的设置</p><ol><li><p>favicon<br> 通过设置<code>favicon</code>和<code>apple_touch_icon</code>来设置浏览器标签图标,可以使用连接资源,也可以使用本地资源路径</p><p> <img src="/img/fluid-options-1.png" alt="fluid主题设置" title="fluid主题设置"></p><p> <img src="/img/fluid-options-2.png" alt="fluid主题设置" title="fluid主题设置"></p></li><li><p>打字机效果</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">fun_features:# 为 subtitle 添加打字机效果# Typing animation for subtitletyping:    enable: true# 打印速度，数字越大越慢# Typing speed, the larger the number, the slower    typeSpeed: 70# 游标字符# Cursor character    cursorChar: &quot;_&quot;# 是否循环播放效果# If true, loop animation    loop: false# 为文章内容中的标题添加锚图标 # Add an anchor icon to the title on the post page<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>颜色的修改</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">color:    # body 背景色    # Color of body background    body_bg_color: &quot;#eee&quot;    # 暗色模式下的 body 背景色，下同    # Color in dark mode, the same below    body_bg_color_dark: &quot;#181c27&quot;    # 顶部菜单背景色    # Color of navigation bar background    navbar_bg_color: &quot;#2f4154&quot;    navbar_bg_color_dark: &quot;#1f3144&quot;    # 顶部菜单字体色    # Color of navigation bar text    navbar_text_color: &quot;#fff&quot;    navbar_text_color_dark: &quot;#d0d0d0&quot;    # 全局字体色    # Color of global text    text_color: &quot;#3c4858&quot;    text_color_dark: &quot;#c4c6c9&quot;    # 全局次级字体色（摘要、简介等位置）    # Color of global secondary text (excerpt, introduction, etc.)    sec_text_color: &quot;#718096&quot;    sec_text_color_dark: &quot;#a7a9ad&quot;    # 文章正文字体色    # Color of post text    post_text_color: &quot;#2c3e50&quot;    post_text_color_dark: &quot;#c4c6c9&quot;    # 文章正文字体色（h1 h2 h3...）    # Color of Article heading (h1 h2 h3...)    post_heading_color: &quot;#1a202c&quot;    post_heading_color_dark: &quot;#c4c6c9&quot;    # 文章超链接字体色    # Color of post link    post_link_color: &quot;#0366d6&quot;    post_link_color_dark: &quot;#1589e9&quot;    # 超链接悬浮时字体色    # Color of link when hovering    link_hover_color: &quot;#30a9de&quot;    link_hover_color_dark: &quot;#30a9de&quot;    # 超链接悬浮背景色    # Color of link background when hovering    link_hover_bg_color: &quot;#f8f9fa&quot;    link_hover_bg_color_dark: &quot;#364151&quot;    # 主面板背景色    # Color of main board    board_color: &quot;#fff&quot;    board_color_dark: &quot;#252d38&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>搜索功能</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件# Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index filessearch:    enable: true  # 将这个打开就可以实现站内搜索,默认自动打开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>footer</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">footer:# 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题# HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more peoplecontent: &#39;&lt;div&gt;这里用来设置页面底部文字展示,支持HTML&lt;&#x2F;div&gt;&#39;# 展示网站的 PV、UV 统计数# Display website PV and UV statisticsstatistics:    enable: true# 统计数据来源，使用 leancloud 需要设置 &#96;web_analytics: leancloud&#96; 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常# Data source. If use leancloud, you need to set the parameter in &#96;web_analytics: leancloud&#96;# Options: busuanzi | leancloudsource: &quot;busuanzi&quot;# 页面显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同# Displayed text, &#123;&#125; is a placeholder for numbers (must be included), the same belowpv_format: &quot;总访问量 &#123;&#125; 次&quot;uv_format: &quot;总访客数 &#123;&#125; 人&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="config-yml的一些设置"><a href="#config-yml的一些设置" class="headerlink" title="_config.yml的一些设置"></a>_config.yml的一些设置</h3> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># Sitetitle: 博客主题名称subtitle: &#39;副标题&#39;description: &#39;博客描述&#39;keywords: &#39;搜索关键词&#39;author: 作者名称language: zh-CN  # 语言timezone: &#39;Asia&#x2F;Shanghai&#39;   # 时区设置   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果需要更换banner图片却又找不到合适的图片该怎么办?<br>兄弟莫慌~<br>附上官方链接: <a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>hexo主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于gitee的PicGo的搭建</title>
    <link href="/2021/12/13/hexo/picGo/"/>
    <url>/2021/12/13/hexo/picGo/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  想着做一个图床,方便博客的图片管理以及减少静态资源的占用量</p><h3 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a>PicGo介绍</h3><blockquote><p>一个用于快速上传图片并获取图片 URL 链接的工具</p></blockquote><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS）| control+shift+p（Windows\Linux)</li><li>支持插件系统，已有插件支持 Gitee、青云等第三方图床</li><li>更多第三方插件。</li><li>支持通过发送 HTTP 请求调用 PicGo 上传（v2.2.0+)</li></ul><h3 id="准备搭建"><a href="#准备搭建" class="headerlink" title="准备搭建"></a>准备搭建</h3><blockquote><p>环境准备: </p></blockquote><ul><li><a href="https://git-scm.com/">git</a></li><li><a href="https://gitee.com/">gitee</a></li><li><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></li></ul><h3 id="Gitee准备"><a href="#Gitee准备" class="headerlink" title="Gitee准备"></a>Gitee准备</h3><ol><li>注册<a href="https://gitee.com/login">gitee</a>账号(默认都安装了git,这里就不介绍了)  </li></ol><p><img src="/img/gitee-login-1.png" alt="gitee注册界面" title="gitee注册步骤一"><br><img src="/img/gitee-login-2.png" alt="gitee注册界面" title="gitee注册步骤二"><br><img src="/img/gitee-login-3.png" alt="gitee注册界面" title="gitee注册步骤三"></p><ol start="2"><li>创建仓库</li></ol><p><img src="/img/gitee-create-store-1.png" alt="gitee新建仓库界面" title="gitee新建仓库步骤一"><br><img src="/img/gitee-create-store-2.png" alt="gitee新建仓库界面" title="gitee新建仓库步骤二"></p><ol start="3"><li>配置私人令牌</li></ol><p><img src="/img/gitee-picgo-set-1.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤一"><br><img src="/img/gitee-picgo-set-2.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤二"><br><img src="/img/gitee-picgo-set-3.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤三"><br><img src="/img/gitee-picgo-set-4.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤四"><br><img src="/img/gitee-picgo-set-5.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤五"><br><img src="/img/gitee-picgo-set-6.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤六"></p><h3 id="PicGo准备"><a href="#PicGo准备" class="headerlink" title="PicGo准备"></a>PicGo准备</h3><ol><li>点击进入下载地址连接(<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a>)</li></ol><p><img src="/img/picgo-pack.png" alt="下载对应的PicGo安装包" title="下载对应的PicGo安装包"></p><blockquote><p><strong>Tips:</strong> 选择对应的下载版本,建议不要用beta版本</p></blockquote><ol start="2"><li><p><strong>下载成功后一直下一步安装即可。</strong></p></li><li><p>PicGo配置( <strong>安装成功后</strong>)</p></li></ol><p><img src="/img/picgo-setting-1.png" alt="PicGo配置" title="PicGo配置步骤一"><br><img src="/img/picgo-setting-2.png" alt="PicGo配置" title="PicGo配置步骤二"><br><img src="/img/picgo-setting-3.png" alt="PicGo配置" title="PicGo配置步骤三"><br><img src="/img/picgo-setting-4.png" alt="PicGo配置" title="PicGo配置步骤四"><br><img src="/img/picgo-setting-5.png" alt="PicGo配置" title="PicGo配置步骤五"><br><img src="/img/picgo-setting-6.png" alt="PicGo配置" title="PicGo配置步骤六"><br><img src="/img/picgo-setting-7.png" alt="PicGo配置" title="PicGo配置步骤七"><br><img src="/img/picgo-setting-8.png" alt="PicGo配置" title="PicGo配置步骤八"></p><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><blockquote><p>示例链接: <a href="https://gitee.com/roily/test-pic-bed/raw/master/img/test033.png">https://gitee.com/roily/test-pic-bed/raw/master/img/test033.png</a></p></blockquote><ul><li>一些需要注意的问题:<ol><li>当使用图床的url后,在微信打开无法显示,应该是微信做了某些限制,手机浏览器和钉钉内部打开是可以的。<br><img src="/img/picgo-waring.jpg" alt="PicGo问题" title="PicGo问题"></li><li>为什么不使用github做为图床仓库?<br>因为github在国内访问速度较慢,所以没有考虑,github也是可以做图床的。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>picGo</tag>
      
      <tag>gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid配置使用</title>
    <link href="/2021/12/10/hexo/hexoFluid/"/>
    <url>/2021/12/10/hexo/hexoFluid/</url>
    
    <content type="html"><![CDATA[<h3 id="Fluid介绍"><a href="#Fluid介绍" class="headerlink" title="Fluid介绍"></a>Fluid介绍</h3><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> 是基于 Hexo 的一款 Material Design 风格的主题</p><ul><li><p>优势<br>1.设计遵循简洁至上，同时具有轻快的体验，和优雅的颜值；<br>2.提供大量定制化配置项，使每个用户使用该主题都能具有独特的样式；<br>3.响应式页面，适配手机、平板等设备；<br>4.为数不多内置支持 LaTeX 语法公式的主题。</p></li><li><p>特性<br>1.图片懒加载<br>2.自定义代码高亮方案<br>3.内置多语言<br>4.内置多款评论插件<br>5.外部覆盖配置<br>6.静态资源配置<br>7.文章搜索<br>8.页脚备案信息<br>9.网页访问统计<br>10.支持 LaTeX 数学公式<br>11.音乐播放器</p><blockquote><p><strong>Tips:</strong><br>  Fluid主题github仓库<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a><br>  hexo还有很多主题,具体可以查看<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3></li><li><p>方法1(推荐): Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令</p><ol><li><p>输入指令</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install --save hexo-theme-fluid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><img src="/img/fuild-save.png" alt="Fluid版本下载" title="Fluid版本下载"></p></li><li><p>在与<code>_config.yml</code>文件平级的目录下,新建文件<code>_config.fluid.yml</code><br><img src="/img/fuild-create-1.png" alt="创建Fluid配置文件" title="创建Fluid配置文件"></p></li><li><p>创建文件后,打开Fluid的github仓库地址: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a>,进入仓库后点击打开Fluid仓库中的<code>_config.yml</code>文件<br><img src="/img/Fluid-Change-1.png" alt="打开_config.yml文件" title="打开_config.yml文件"></p></li><li><p>打开后,复制全部代码,粘贴入刚才创建的<code>_config.fluid.yml</code>文件中<br><img src="/img/Fluid-Change-2.png" alt="复制_config.yml文件" title="复制config.yml文件"></p></li><li><p>粘贴成功后,点击<code>_config.yml</code>文件,点击搜索<code>theme</code>关键字,将之前的默认主题landscape换成<code>fluid</code><br><img src="/img/Fluid-Change-3.png" alt="更换fluid主题" title="更换fluid主题"></p></li></ol><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">最后执行:    hexo g    hexo s    就可以本地运行打开查看已经配置好的fluid主题~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p><img src="/img/Fluid-Change-4.png" alt="完成更换fluid主题" title="完成更换fluid主题"></p></li><li><p>方法2:</p><ol><li>进入github仓库下载最新 release 版本解压到themes目录并将解压出的文件夹重命名为 fluid，最后将整个fluid拷贝至脚手架的themes文件夹内</li></ol><p>  <img src="/img/fluid-action2-1.png" alt="下载最新release压缩包" title="下载最新release压缩包"></p><p>  <img src="/img/fluid-action2-2.png" alt="重命名release压缩包" title="重命名release压缩包"></p><p>  <img src="/img/fluid-action2-3.png" alt="放置release压缩包" title="放置release压缩包"></p><ol start="2"><li>完成后同样需要将<code>_config.yml</code>文件的<code>theme</code>关键字,更换成<code>fluid</code><br><img src="/img/Fluid-Change-3.png" alt="更换fluid主题" title="更换fluid主题"><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">最后执行:  hexo g  hexo s  同方法1一样可以本地运行打开查看已经配置好的fluid主题~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <img src="/img/Fluid-Change-4.png" alt="完成更换fluid主题" title="完成更换fluid主题"></p></li></ul><h3 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h3><blockquote><p>在使用方法2完成了主题更换的前提下,我们之后如果要在主题上进行修改,每次修改都需要到/themes/fluid下修改主题的<code>_config.yml</code>文件，这样特别麻烦，并且在版本更新时，都要注意怕被新的<code>_config.yml</code>文件替换掉，又回滚到了初始的代码，所以官方也建议将主题的<code>_config.yml</code>文件复制一份重命名为<code>_config.fluid.yml</code>文件到Hexo脚手架的根目录下，和<code>_config.yml</code>文件并列。这样，在官方更新版本时，直接覆盖.themes/fluid下的文件就可以了，不会影响到<code>_config.fluid.yml</code>文件</p></blockquote><p>  <img src="/img/fluid-action2-4.png" alt="备份fluid主题文件" title="备份fluid主题文件"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
      <tag>hexo主题</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vueの修饰符</title>
    <link href="/2021/11/18/Vue/keyModifier/"/>
    <url>/2021/11/18/Vue/keyModifier/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>本篇文章是专门用来介绍vue的修饰符</li><li>包括了<strong>指令的修饰符</strong>,<strong>事件修饰符</strong>,<strong>按键修饰符</strong>,<strong>其它修饰符</strong></li><li>了解常用的修饰符,使某些场景的开发变得更加简便</li></ul><h3 id="指令的修饰符"><a href="#指令的修饰符" class="headerlink" title="指令的修饰符"></a>指令的修饰符</h3><p>简介: 指令的修饰符包括了<code>v-model</code>的修饰符和<code>v-bind</code>的修饰符,这些都是一些比较常用的修饰符,有便于我们平常的开发</p><ul><li><p>v-model的修饰符<br>  <code>v-model</code>的修饰符分为3种<code>.lazy,.trim,.number</code></p><ol><li><strong>.lazy</strong><blockquote><p><code>v-model</code>在添加了<code>.lazy</code>修饰符之后只有等输入框失去焦点之后或者按下enter键才会显示输入的内容</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;input v-model.lazy&#x3D;&quot;demoText&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;    &lt;h1&gt;&#123;&#123; demoText &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div> <img src="/img/lazy.gif" alt=".lazy示意"></li><li><strong>.trim</strong><blockquote><p><code>.trim</code>修饰符会将双向绑定的内容的首尾空格进行去除,和字符串的<code>trim</code>方法效果是一致的,如果一直输入空格按钮,则绑定的值一直为<code>&#39;&#39;(空字符串)</code>,中间的空格是无法清除的。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &#x2F;&#x2F; 如果输入demoText为 &#39; abc &#39; 则显示为:abc    &#x2F;&#x2F; 如果输入demoText为 &#39;a bc &#39; 则显示为:a bc    &lt;input v-model.trim&#x3D;&quot;demoText&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;    &lt;h1&gt;&#123;&#123; demoText &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><strong>.number</strong><blockquote><p><code>v-model</code>在加了<code>.number</code>修饰符之后,会把输入的数值从字符串或其他类型转换为number类型</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &#x2F;&#x2F; 如果输入demoText为 &#39;&#39;    则 typeText为string    &#x2F;&#x2F; 如果输入demoText为 &#39;123&#39; 则 typeText为number    &lt;input v-model.number&#x3D;&quot;demoText&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;    &lt;h1&gt; &#123;&#123; typeText &#125;&#125; &lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;    import &#123; defineComponent ,ref ,computed&#125; from &#39;vue&#39;    export default defineComponent(&#123;        setup()&#123;            let demoText &#x3D; ref(&#39;&#39;)            let typeText &#x3D; computed(()&#x3D;&gt;&#123;              return typeof demoText.value            &#125;)            return &#123;                demoText,                typeText            &#125;        &#125;    &#125;)&lt;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li><li><p>v-bind的修饰符<br><code>v-bind</code>的常用修饰符为<code>.sync</code></p><ol><li><strong>.sync</strong><blockquote><p><code>v-bind</code>的属性名之后添加<code>.sync</code>,可以通过<code>$emit(&#39;update:属性名&#39;, value)</code>实现父子组件的数据双向绑定</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div class&#x3D;&quot;demo&quot;&gt;        &#x2F;*             实际扩展为:            &lt;child-comp :label&#x3D;&quot;label&quot; @update:label&#x3D;&quot;val &#x3D;&gt; label &#x3D; val&quot; &#x2F;&gt;        *&#x2F;        &lt;child-comp :label.sync&#x3D;&quot;label&quot; &#x2F;&gt;        &lt;div&gt;&#123;&#123; label &#125;&#125;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&#x2F;&#x2F; childComp.vue&lt;template&gt;    &lt;div class&#x3D;&quot;demoChild&quot;&gt;        &lt;button @click&#x3D;&quot;$emit(&#39;update:label&#39;,&#39;修改父组件的label&#39;)&quot;&gt;            修改        &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>当点击childComp.vue的button时,父组件的label则会改为 <em>修改父组件的label</em></p></blockquote></li></ol><blockquote><p>值的注意的是,vue3.0已经将<code>.sync</code>修饰符移除,与<code>v-model</code>进行了一个融合<br> <img src="/img/sync.png" alt=".sync修饰符3.0移除">  </p></blockquote></li></ul><h3 id="事件的修饰符"><a href="#事件的修饰符" class="headerlink" title="事件的修饰符"></a>事件的修饰符</h3><p>简介: 针对事件行为设计的修饰符,比如<code>stopPropagation()[阻止冒泡]</code>,<code>preventDefault()[阻止默认行为]</code>等等…</p><ul><li>stop –&gt; event.stopPropagation()阻止事件冒泡<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 阻止单击事件冒泡，当点击box2时就不会触发box1的点击事件，若不加则会触发 --&gt;&lt;div class&#x3D;&quot;box1&quot; @click&#x3D;&quot;btn&quot;&gt;&lt;div class&#x3D;&quot;box2&quot; @click.stop&#x3D;&quot;btn1&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>prevent -&gt; event.preventDefault(),阻止事件默认行为<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>capture –&gt; 来实现捕获触发事件的机制<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 添加事件侦听器时使用事件捕获模式，先执行外层盒子事件，再执行里面盒子事件 --&gt;&lt;div v-on:click.capture&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>self –&gt; 实现只有点击当前元素时候，才会触发事件处理函数（只会阻止自己身上的冒泡行为，并不会阻止真正的冒泡）<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 只当事件在该元素本身（而不是子元素）才去执行 --&gt;&lt;div v-on:click.self&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>once –&gt; 只触发一次处理函数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;button v-on:click.once&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li>passive –&gt; 对应 addEventListener 中的 passive 选项；表示它不会阻止事件的默认行为(通常来说，滚动页面的默认行为被阻止了，页面必须静止不动，但浏览器无法预先知道一个监听器会不会调用 preventDefault(),只有等滚动监听器执行完再去执行默认行为，而监听器执行是要耗时的，而且80%的滚动监听器是不会阻止默认行为的，所以浏览器白等，passive 监听器诞生了，可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了。）<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 &#96;onScroll&#96; 完成  --&gt;&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况 --&gt;&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong>.passive 修饰符尤其能够提升移动端的性能</strong><br>不要把 <code>.passive</code>和<code>.prevent</code>一起使用,因为<code>.prevent</code>将会被忽略，同时浏览器可能会向你展示一个警告。<code>passive</code>会告诉浏览器你不想阻止事件的默认行为</p></blockquote></li><li>事件修饰符的小技巧<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 修饰符可以串联，阻止默认事件  --&gt;&lt;a v-on:click.stop.prevent&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul><h3 id="按键的修饰符"><a href="#按键的修饰符" class="headerlink" title="按键的修饰符"></a>按键的修饰符</h3><p>简介:通过键盘或鼠标的按键指定事件的触发方法(由于keyCode在Vue3.0废弃并且在一些高版本浏览器不支持,本文对keyCode形式的不作介绍)</p><ul><li>enter 回车键</li><li>tab</li><li>delete (捕获 “删除” 和 “退格” 键)</li><li>esc</li><li>space</li><li>up</li><li>down</li><li>left  (如果是鼠标就是左键)</li><li>right (如果是鼠标就是右键)</li><li>ctrl</li><li>alt</li><li>shift</li><li>meta  (MIT计算机键盘上的的一个特殊键)</li><li>middle(鼠标的中间滚轮键)</li></ul><blockquote><p>示例:<br>    <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 按下回车键触发search方法&lt;input type&#x3D;&quot;text&quot; v-on:keyup.enter&#x3D;&quot;search&quot; &#x2F;&gt;&#x2F;&#x2F; 按下鼠标中间滚轮键触发search方法&lt;button v-on:cilck.middle&#x3D;&quot;search&quot;&gt; 查找 &lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p></blockquote><h3 id="补充的修饰符"><a href="#补充的修饰符" class="headerlink" title="补充的修饰符"></a>补充的修饰符</h3><p>简介: 介绍了<code>.exact</code>修饰符和<code>.native</code>修饰符</p><ul><li>.exact修饰符<blockquote><p>作用: 精准的控制触发事件的按钮</p>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 只有按下enter键才可以触发search方法,如果同时按下 alt + enter 键,则不会触发&lt;input type&#x3D;&quot;text&quot; v-on:keyup.enter.exact&#x3D;&quot;search&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></blockquote></li><li>.native修饰符<blockquote><p>作用: 将原生事件绑定到组件,组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件</p>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;*     常用于一个纯icon组件,进行一个事件的绑定*&#x2F;&lt;template&gt;    &lt;comp @click.native&#x3D;&quot;consoleDetails&quot; &#x2F;&gt;&lt;&#x2F;template&gt;comp.vue    &lt;div&gt;        &lt;img src&#x3D;&quot;xxx&quot;&gt;    &lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>值的注意: 在vue3.0中,将<code>.native</code>修饰符也进行了废弃,如果需要达到<code>.native</code>的修饰符的方法则不能将绑定在组件标签上的方法注册进<code>emits</code>选项中(或者<code>defineEmits([])</code>)</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的基础搭建</title>
    <link href="/2021/11/18/hexo/hexoCreate/"/>
    <url>/2021/11/18/hexo/hexoCreate/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><ul><li>风一般的速度<br>Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 </li><li>流畅的撰写<br>支持GitHub Flavored Markdown和所有Octopress的插件。 </li><li>扩展性<br>Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less.</li></ul><h2 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h2><ul><li>所需环境<ul><li><a href="http://nodejs.cn/api/" title="Nodejsの中文镜像网站">Node.js</a></li><li><a href="https://git-scm.com/" title="git官网">git</a></li></ul></li><li>所需工具<ul><li><a href="https://github.com/" title="最大的同性交友网站">github</a></li><li><a href="https://hexo.io/zh-cn/" title="hexo中文官网">hexo</a></li></ul></li></ul><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket.png" />  <font size=5 face='微软雅黑' color="#1f87dd" style="font-weight:700;"> fist-step </font></div><ul class="nano-ul-flex">  <li>    <div >安装hexo脚手架</div>    <div class="nano-pointer">npm install -g hexo-cli</div>    <hr />  </li>   <li>    <div >初始化hexo文件夹</div>    <div class="nano-pointer">hexo init (初始化hexo)</div>    <div class="nano-pointer">npm install</div>    <hr />    <img src="/img/hexo-step1.png"/>    <div class="nano-tips"><span>Tips:</span> 如果出现报错,一般都是node版本过低导致,升级一下node版本就可以了(博主的node版本是v14.18.1)</div>    <hr />  </li>  <li>    <div >本地启动hexo</div>    <div class="nano-pointer">hexo g (生成hexo)</div>    <div class="nano-pointer">hexo s (启动本地服务器,这一步之后就可以通过http://localhost:4000 查看)</div>    <img src="/img/hexo-step2.png"/>    <div>&nbsp;</div>    <img src="/img/hexo-step3.png"/>    <div class="nano-success">    <img src="/img/success-new.png" />    这样就暂时先完成了本地博客的环境搭建啦~</div>    <div class="nano-tips"><span>Tips:</span> 如果出现端口占用问题可以输入      <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer">hexo s -p 41</font>      暂时切换端口    </div>    <hr />  </li></ul> <div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket.png">  <font size=5 face='微软雅黑' color="#1f87dd" style="font-weight:700;"> twice-step </font></div><ul class="nano-ul-flex">  <li>    <a href="https://github.com/">创建github账号</a>  </li>  <li>   <span>创建一个新的github仓库</span>   <img src="/img/github-create-1.png" />   <hr />   <img src="/img/github-create-2.png" />    <hr />    <img src="/img/github-create-3.png" />    <div class="nano-success">      <img src="/img/success-new.png" />    这样就完成了github的环境配置了~</div>  </li></ul><div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket.png" />  <font size=5 face='微软雅黑' color="#1f87dd" style="font-weight:700;"> third-step </font></div><ul class="nano-ul-flex">  <li>    <div >配置本地hexo部署到GitHub的文件</div>    <div>      编辑根目录下_config.yml文件,查找并切换到deploy字段位置,如图进行编辑:    </div>    <img src="/img/push-hexo1.png" />    <div class="nano-pd">      保存后安装扩展: <span class="nano-pointer">npm install hexo-deployer-git --save </span>      </div>    <div class="nano-tips"><span>Tips:</span> hexo的语法规定 <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> : </font>后面      <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer">必须有一个空格</font>    </div>    <hr />  </li>  <li>    <div >配置SSH Key 到GitHub</div>    <div>      <div>在Git Bash中输入: <span class="nano-pointer">ssh-keygen -t rsa -C "你的github邮箱号" </span> </div>      <div>之后按三下回车出现以下内容</div>      <img  src="/img/ssh-key-1.png" />    </div>    <hr />    <div>      <div>找到.ssh文件夹，并打开其中的id_rsa.pub文件，复制里面的内容</div>      <img  src="/img/ssh-key-2.png" />    </div>    <hr />    <div>      <div>之后按下面图片步骤执行</div>      <img  src="/img/ssh-key-3.png" />      <hr/>      <img  src="/img/ssh-key-4.png" />       <hr/>      <img  src="/img/ssh-key-5.png" />      <hr/>      <img  src="/img/ssh-key-6.png" />      <hr/>      <img  src="/img/ssh-key-7.png" />      <hr/>      <div>此时在git bush中输入 <span class="nano-pointer">ssh -T git@github.com<span></div>      <img  src="/img/ssh-key-8.png" />      <div class="nano-success">      <img src="/img/success-new.png" />    如果出现了以上语句,则说明设置成功~</div>    </div>    <hr />  </li>   <li>    <div >推送本地hexo 到GitHub</div>    <div>      <div>在Git Bash中设置用户信息:</div>      <img src="/img/hexo-to-push-1.png" />      <hr />      <div>编辑根目录下_config.yml文件,查找并切换到url字段位置,如图进行编辑:</div>      <img src="/img/hexo-to-push-2.png" />      <div class="nano-tips"><span>Tips:</span>  <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> 配置之后,初次上传就可以有样式了~ </font>      </div>      <hr />    </div>  </li></ul> <h2 id="搭建完成"><a href="#搭建完成" class="headerlink" title="搭建完成"></a>搭建完成</h2><div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket-succes.png" />  <font size=5 face='微软雅黑' color="red" style="font-weight:700;"> last-step </font></div><ul class="nano-ul-flex">  <li>    输入 <span class="nano-pointer">hexo d</span> 指令推送到远端    <img src="/img/hexo-to-push-5.png">    <div class="nano-tips"><span>Tips:</span>  <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> 网络原因可能会推送不成功,多试几下就好了~ </font>    </div>    <hr />  </li>   <li>    推送成功!    <img src="/img/hexo-to-push-3.png">    <hr />    <img src="/img/hexo-to-push-7.jpg">     <div class="nano-tips"><span>Tips:</span>  <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> 因为picGo一直推不上去pc端的界面截图,所以展示了移动端的效果~ </font>    </div>     <hr />  </li>  <div class="nano-success">    <img src="/img/success-new.png" />    这样就完成了博客的搭建与上传~</div></ul> <h2 id="最后の一些话"><a href="#最后の一些话" class="headerlink" title="最后の一些话"></a>最后の一些话</h2><ul><li><p>附上一些其它常用指令 <br/></p><img src="/img/instruct-hexo.png" /></li><li><p>其它念叨 <br/></p><ul><li>之后也会陆续推出使用picgo搭配gitee做的图床教程,主要是为了减少静态资源的体积,本文的所有图片均来自gitee创建的图床~</li><li>一开始不用gitee而选择github的原因是因为gitee的pages服务需要人工审核,审了我蛮久的,github不需要审核,就是需要科学上网,所以gitee也是可以做博客的,有兴趣的同学可以自己尝试一下~</li><li>hexo还有主题这些,后面也会出一些教程,毕竟我也才开始弄hexo,也不是很会,可能只会写一些很浅显的东西- -</li><li>纪念第一篇博文,完结撒花,我去推了 2021-11-26</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
