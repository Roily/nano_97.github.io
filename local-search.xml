<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jsBasic</title>
    <link href="/2022/04/10/jsBasic/"/>
    <url>/2022/04/10/jsBasic/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础运行知识</title>
    <link href="/2022/04/10/JavaScript/jsBasic/"/>
    <url>/2022/04/10/JavaScript/jsBasic/</url>
    
    <content type="html"><![CDATA[<h2 id="JS代码是如何在浏览器中运行的"><a href="#JS代码是如何在浏览器中运行的" class="headerlink" title="JS代码是如何在浏览器中运行的?"></a>JS代码是如何在浏览器中运行的?</h2><ol><li>浏览器通过DNS解析域名为IP地址,访问IP地址返回html文件</li><li>html文件下载完成后,解析html文件<br>(1) 解析到script标签,就会去服务器下载对应的JS文件<br>(2) 遇到link标签,就会去服务器下载对应的css文件</li><li>等到js文件下载完成后,浏览器就会通过浏览器内核,解析运行JS代码</li></ol><h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ol><li>将html解析形成DOM树,此时遇到JS标签则会体质解析html,优先通过JS引擎加载和执行JS代码(这里可能会执行DOM操作),最后形成DOM结构树</li><li>将css层叠样式表解析成样式规则</li><li>将DOM树和样式规则组合形成渲染树(RenderTree)并且布局引擎(Layout)进行布局操作</li><li>绘制引擎(paint)将渲染树绘制并且展示在浏览器页面上</li></ol><blockquote><p><strong>注意:</strong> 在html被浏览器解析过程中,如果遇到了JS标签,则会停止解析html,优先加载和执行JS代码</p></blockquote><h2 id="JS引擎-V8引擎"><a href="#JS引擎-V8引擎" class="headerlink" title="JS引擎(V8引擎)"></a>JS引擎(V8引擎)</h2><ol><li><p>浏览器内核与JS引擎的关系</p><blockquote><p>浏览器内核<strong>包含</strong>JS引擎,JS引擎只负责解析和JS代码</p></blockquote></li><li><p>V8引擎工作原理<br>(1) 解析JS源代码(词法解析,语法解析)<br>(2) 解析后形成AST抽象语法树<br>(3) 通过Ignition库收集信息并编译成字节码,再把字节码编译成机器码执行运行结果</p></li><li><p>Q: 如果有一段JS代码频繁被使用,每次都把这部分代码转成字节码再编译成机器码会消耗很多性能,该如何解决?<br>A: Ignition库会将频繁调用的JS代码标记为<strong>hot</strong>,之后通过TurboFan库转换为优化后的机器码进行存储,下次再调用时直接调用存储的机器码运行</p></li><li><p>Q: 因为JS代码是弱类型语言,如果在一段频繁调用的JS代码使用逻辑运算时,更改了参数类型的值,导致计算方式不一致生成的机器码也不一致,该如何解决?<br>A: JS引擎会有逆优化(Deoptimization)的操作,反向转为字节码,再通过字节码转为机器码,当然这是一个比较消耗性能的操作<br>M: 这也是为什么在解析TypeScript转换的JS代码时效率更高的原因之一,TypeScript做了类型的强校验,省去了逆优化的操作</p></li><li><p>Q: JS引擎为什么先转为字节码,再转为机器码,而不是直接转为机器码?<br>A: 因为机器码比较占内存空间,字节码所占用的空间远远低于了机器码,总结就是<strong>牺牲时间来换取空间</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES.x</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の一些踩坑点</title>
    <link href="/2022/03/04/miniProgram/basic-08/"/>
    <url>/2022/03/04/miniProgram/basic-08/</url>
    
    <content type="html"><![CDATA[<h2 id="WXS的使用"><a href="#WXS的使用" class="headerlink" title="WXS的使用"></a>WXS的使用</h2><ol><li>小程序如何使用在页面上使用类似于vue2的过滤器属性?<br>A: WXS</li><li>使用<ol><li>新建一个wxs文件,里面只支持js的es5语法,在里面写转换函数,通过module.exports = {方法名} 导出</li><li>在需要使用工具类函数的页面引入wxs标签<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; module 就是类似于整个模块名称,通过这个名称获取里面的方法&lt;wxs sr&#x3D;&quot;..&#x2F;文件.wxs&quot; module&#x3D;&quot;format&quot;&gt;&lt;&#x2F;wxs&gt;&lt;view&gt;&#123;&#123; format.moment(time) &#125;&#125;&lt;&#x2F;view&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>wx:for<ol><li>重命名item和index<br>Q:为什么要重命名?<br>A:当双重wx:for循环时必须得把内部wx:for循环的item和index做修改</li><li>示例:<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 通过 wx:for-item&#x2F;wx:for-index重命名 --&gt;  &lt;block wx:for&#x3D;&quot;&#123;&#123; arr &#125;&#125;&quot;&gt;    &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;&#x2F;view&gt;    &lt;view&gt; &#123;&#123;index&#125;&#125; &lt;&#x2F;view&gt;    &lt;!-- 通过 wx:for-item&#x2F;wx:for-index重命名 --&gt;    &lt;view wx:for&#x3D;&quot;&#123;&#123; arr2 &#125;&#125;&quot; wx:for-item&#x3D;&quot;itm&quot; wx:for-index&#x3D;&quot;ind&quot; &gt;        &#123;&#123; itm &#125;&#125;-&#123;&#123; ind &#125;&#125;    &lt;&#x2F;view&gt;  &lt;&#x2F;block&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li><li>wx:if/wx:elif/wx:else<ol><li>与hide区别<blockquote><p>就像v-if和v-show的区别,wx:if是对元素节点进行操作,hide是对样式操作</p></blockquote></li></ol></li></ol><p>  <strong>值的注意:</strong></p><blockquote><p>hide的默认值是true</p></blockquote><h2 id="wxss的背景图引用"><a href="#wxss的背景图引用" class="headerlink" title="wxss的背景图引用"></a>wxss的背景图引用</h2><blockquote><p>不能使用本地资源引用,只能引用在线地址或者把图片转成base64</p></blockquote><h2 id="npm包依赖安装关于基础库的bug"><a href="#npm包依赖安装关于基础库的bug" class="headerlink" title="npm包依赖安装关于基础库的bug"></a>npm包依赖安装关于基础库的bug</h2><blockquote><p>有些Npm依赖只支持特定的小程序基础库版本或者压根不支持小程序,所以在安装依赖的时候需要查看一下是否支持小程序</p></blockquote><h2 id="npm包构建流程"><a href="#npm包构建流程" class="headerlink" title="npm包构建流程"></a>npm包构建流程</h2><ol><li>初始化项目包的npm<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm init --y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li>npm安装对应依赖包</li><li>详情 -&gt; 勾选使用npm模块选项 </li><li>点击菜单栏 : 工具 -&gt; 构建npm (每次下载新的依赖都得重新构建)</li><li>通过require或者import方法引用模块<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const moment &#x3D; require(&#39;moment&#39;)const value &#x3D; moment(+new Date()).format(&#39;YYYY-MM-DD&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>构建后再project.config.json文件中进行配置<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;   &quot;setting&quot;: &#123;       &quot;packNpmManually&quot;: true,       &quot;packNpmRelationList&quot;: [        &#123;             &quot;packageJsonPath&quot;: &quot;.&#x2F;package.json&quot;,             &quot;miniprogramNpmDistDir&quot;: &quot;.&#x2F;&quot;         &#125;       ]   &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p><strong>注意：</strong> </p><blockquote><p>由于目前新版开发者工具创建的小程序目录文件结构问题，npm构建的文件目录为miniprogram_npm，并且开发工具会默认在当前目录下创建miniprogram_npm的文件名，所以新版本的miniprogramNpmDistDir配置为’./‘即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の登录流程</title>
    <link href="/2022/03/04/miniProgram/basic-07/"/>
    <url>/2022/03/04/miniProgram/basic-07/</url>
    
    <content type="html"><![CDATA[<h2 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">    小程序端:         (1) 在小程序通过wx.login API获取临时的code        (2) 调用接口将code传递给自己的服务器    自己服务器端:        (1) 获取小程序内传来的临时的code        (2) 将临时的code + appId + appsecret发送给微信小程序服务器,获取 openId 和 session_key [这个时候用户不知道自己已经登录成功]        (3) 自己服务器内将 openId和session_key 组合生成有期限的token,返回给小程序端    小程序端:        (1) 获取自己服务器端内传递的token,并存储到storeage中        (2) 将需要记录用户操作的接口中携带这个token发送给自己的服务器端        自己服务器端:        (1) 将接口传递的token进行解析,解析出openId和session_key,将操作保存在数据库内,避免向微信服务器多次请求获取openId        如果用户更换手机?        (1) 判断storage中是否存储了token,如果未存储则重复登录流程        (2) 如果存储了token,判断是否已经过期,如果过期了则重新登录,如果没有过期,继续判断session_key是否过期,如果没有过期,则继续使用这个token进行用户校验,反之则重新登录判断session_key是否过期:wx.checkSession(&#123;      success: (res) &#x3D;&gt; &#123;        resolve(true)      &#125;,      fail: () &#x3D;&gt; &#123;        reject(false)      &#125;    &#125;)  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ol><li>什么是openId?<blockquote><p>openId 用户身份的唯一标识,用openId去识别用户 [unionId用于第三方登录]</p></blockquote></li><li>什么是unionId?<blockquote><p>unionId也是唯一的标识,用于多平台(APP,公众号,网页)授权时进行标识识别,多个产品源进行数据共享<br> 多平台共享时需要同时绑定手机号(常用),因为可能某个平台不支持微信的登录,需要通过其它的方式进行信息绑定(最多的就是手机号)<br> 所以有些客户端在要求你微信登录之后需要绑定手机号</p></blockquote></li></ol><p>注意: 服务器端openID和unionID都是可以获取的,如果涉及到多端的数据共享,建议直接使用unionID进行校验</p><h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><ol><li>使用getUserProfile API<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">wx.getUserProfile(&#123;  desc: &#39;desc&#39;, &#x2F;&#x2F; 必填  success:(res)&#x3D;&gt;&#123;    console.log(res);    &#x2F;&#x2F; 成功回调  &#125;,  fail:()&#x3D;&gt;&#123;&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p><strong>值得注意:</strong></p><blockquote><p>不允许直接在生命周期方法里获取用户信息,只能通过事件触发获取<br>示例:<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 这里加不加open-type 也可以&lt;button bindtap&#x3D;&quot;getUserProfile&quot; open-type&#x3D;&quot;getUserInfo&quot;&gt;&lt;&#x2F;button&gt;getUserProfile()&#123;  wx.getUserProfile(&#123;      desc: &#39;你好&#39;, &#x2F;&#x2F; 必填      success:(userInfo)&#x3D;&gt;&#123;      &#x2F;&#x2F; 这里获取用户信息          console.log(userInfo);         &#125;,      fail:()&#x3D;&gt;&#123;&#125;  &#125;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p></blockquote><h2 id="获取手机号"><a href="#获取手机号" class="headerlink" title="获取手机号"></a>获取手机号</h2><ol><li>获取手机号<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;button open-type&#x3D;&quot;getPhoneNumber&quot;&gt;获取手机号&lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li></ol><p>  <strong>值得注意:</strong><br>  目前不能直接获取手机号,再调用这个button按钮时会传递一个code,将code传递给自己服务器端的一个接口,接口内部再访问微信的服务器,通过这个code获取手机号码信息</p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の分包</title>
    <link href="/2022/03/04/miniProgram/basic-06/"/>
    <url>/2022/03/04/miniProgram/basic-06/</url>
    
    <content type="html"><![CDATA[<h2 id="使用场景-amp-限制"><a href="#使用场景-amp-限制" class="headerlink" title="使用场景&amp;限制"></a>使用场景&amp;限制</h2><ol><li>优化小程序启动时加载事件,协同开发进行解耦</li><li>限制:<br>(1) <strong>tabbar或者首屏使用的文件不能进行分包</strong><br>(2) 单个小程序打包大小不能超过2MB,使用分包总体小程序包体积不能大于20MB</li></ol><p>  <strong>值得注意:</strong></p><blockquote><p>如果需要分包,应该在小程序开发前期就规划好,定下基础模块,防止往后开发改造目录结构带来麻烦</p></blockquote><h2 id="使用分包"><a href="#使用分包" class="headerlink" title="使用分包"></a>使用分包</h2><ol><li><p>在根目录下简历packageModeName(模块名称)的文件夹</p><blockquote><p>每个文件夹其实都是一个小程序开发目录,可以在里面定义assets,pages等等(app.js这些不需要配置)<br><img src="/img/wx-%E5%88%86%E5%8C%85.png" alt="小程序分包目录结构"></p></blockquote></li><li><p>配置路由</p><blockquote><p>分包后,将app.json文件中分包的文件路由进行相应的删除<br>将微信路由跳转api的路径也进行相应的更改<br>url: ‘/分包模块名称/pages/….’</p></blockquote></li><li><p>subPackage配置(分包配置属性)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">app.json文件配置分包属性&quot;subPackages&quot;: [    &#x2F;&#x2F; 配置分包属性    &#123;        &quot;root&quot;:&quot;packageDetail&quot;,  &#x2F;&#x2F; 分包根目录名称(分包模块名称)        &quot;name&quot;:&quot;pDetail&quot;,        &#x2F;&#x2F; 分包根目录别名,可以不写        &quot;pages&quot;:[                &#x2F;&#x2F; 分包路由配置            &quot;pages&#x2F;detail-search&#x2F;index&quot;,            &quot;pages&#x2F;detail-songs&#x2F;index&quot;,            &quot;pages&#x2F;detail-video&#x2F;index&quot;        ]    &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h2><blockquote><p> 定义: 所有功能(组件依赖,方法依赖)完全不依赖于主包,独立存在的一个包文件<br> 使用场景: 扫描二维码<br> 使用: 在分包配置的对象中设置”independent” : true 属性<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&quot;subPackage&quot;:[  &#123;    &quot;root&quot;: &quot;包模块根目录名称&quot;,    &quot;name&quot;: &quot;包模块别名&quot;,    &quot;pages&quot;:[ ],   &#x2F;&#x2F; 页面路由    &quot;independent&quot; : true &#x2F;&#x2F; 独立分包 属性  &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><br>  <strong>值得注意:</strong><br>      (1) 独立分包时,app.wxss对独立分包的页面不起到作用<br>      (2) 独立分包完全不能依赖主包,相当于做一个独立的页面嵌进应用内<br>      (3) App只能在主包定义,独立分包不行(可以使用getApp方法,如果主包没有下载下来,则获取不到值)<br>      (4) 独立分包不支持插件</p></blockquote><h2 id="分包预下载"><a href="#分包预下载" class="headerlink" title="分包预下载"></a>分包预下载</h2><blockquote><p>定义: 类似于懒加载,优先把主包加载完成,之后在闲置时下载设置预下载的分包<br>使用: 设置<code>preloadRule</code>属性<br>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&quot;preloadRule&quot;:&#123;  &quot;需要分包预下载的页面路径&quot;:&#123;      &quot;newwork&quot;: &quot;wifi&#x2F;all&quot;, &#x2F;&#x2F; 设置在哪个网络环境下可以预下载    &quot; packages&quot;:[ root, name ] &#x2F;&#x2F; 设置预下载的包名,使用root&#x2F;name  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序の数据共享</title>
    <link href="/2022/03/04/miniProgram/basic-05/"/>
    <url>/2022/03/04/miniProgram/basic-05/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>小程序目前没有像vue一样有一个契合性很好的全局状态管理库并且现有的全局状态共享并不是响应式的,但是可以下载相应的依赖包进行全局状态管理并且达到响应式的效果。这篇博文就是介绍一个比较不错的全局状态管理库和小程序本身全局共享数据的特点。</p></blockquote><h2 id="app-js全局共享数据"><a href="#app-js全局共享数据" class="headerlink" title="app.js全局共享数据"></a>app.js全局共享数据</h2><ol><li>在app.js中 声明变量 globalData</li><li>通过getApp( ) 获取app.js对象</li><li>getApp().globalData 获取共享变量<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">App(&#123;  globalData:&#123;    num : 1  &#125;&#125;)&#x2F;&#x2F; page页面(组件页面也是一样的用法)const app &#x3D; getApp()Page(&#123;  useGlobalData()&#123;    console.log( app.globalData ) --&gt; &#123; num:1 &#125;  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <strong>值的注意:</strong></p><blockquote><p>在app里共享的数据不是响应式的</p></blockquote><h2 id="module-模块-引入"><a href="#module-模块-引入" class="headerlink" title="module(模块)引入"></a>module(模块)引入</h2><ol><li>通过es6的模块化语法将数据封装在一个js文件,之后在需要的页面中引入</li></ol><p>  <strong>缺点:</strong> </p><blockquote><p>数据也不是响应式的</p></blockquote><h2 id="hy-event-store-依赖包"><a href="#hy-event-store-依赖包" class="headerlink" title="hy-event-store(依赖包)"></a>hy-event-store(依赖包)</h2><blockquote><p>定义: 是coderWhy老师开发的一个全局状态管理的开发库,语法风格类似于vuex,使用比较便捷,体积也比较小。<br>地址: <a href="https://github.com/coderwhy/hy-event-store">https://github.com/coderwhy/hy-event-store</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の异步api封装&amp;插槽/混入</title>
    <link href="/2022/03/04/miniProgram/basic-04/"/>
    <url>/2022/03/04/miniProgram/basic-04/</url>
    
    <content type="html"><![CDATA[<h3 id="异步API的封装"><a href="#异步API的封装" class="headerlink" title="异步API的封装"></a>异步API的封装</h3><ol><li>为什么要封装微信的异步API?<ol><li>因为异步的原因,可能会与我们代码逻辑有所冲突</li><li>因为微信提供的异步API很繁琐,我们通过你自己的进一步封装,可以更好的调用,减少代码的体积</li></ol></li><li>如何封装?<ol><li>使用<code>promise</code>封装</li><li>示例:<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 我们这里使用微信提供的请求API进行演示,封装逻辑都是一样的const baseUrl &#x3D; &#39;xxx&#39;const request &#x3D; (params,token) &#x3D;&gt; &#123;  return new Promise((resolve, reject) &#x3D;&gt; &#123;    wx.request(&#123;      ...params,      url: params.baseUrl ? params.baseUrl + params.url : baseUrl + params.url,      success: (result) &#x3D;&gt; &#123;        &#x2F;&#x2F; 注意: resolve只能传递一个参数,多个参数可以使用对象传递        resolve(result.data)      &#125;,      &#x2F;&#x2F; 因为fail这里一定返回的是错误信息并reject也是一个方法的调用,所以这里可以简写      fail: reject,      complete: (res) &#x3D;&gt; &#123;&#125;,    &#125;)  &#125;)&#125;export default request<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><p>  <strong>这样,我们在其它js文件引入后,可以进行async await的解析或者promise链式调用</strong></p><h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot(插槽)"></a>slot(插槽)</h2><ol><li><p>slot 用法和vue的默认插槽一样(也有具名插槽)</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 使用:&#x2F;&#x2F;子组件&lt;view&gt;  &lt;slot name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;view&gt;Component(&#123;  options: &#123;    &#x2F;&#x2F; 设置属性开启具名插槽    multipleSlots: true  &#125;&#125;)&#x2F;&#x2F; 父组件中&lt;component&gt;  &lt;view slot&#x3D;&quot;name&quot;&gt;&lt;&#x2F;view&gt;&lt;&#x2F;component&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>如何在封装包含插槽的组件时,如果不传递传参默认展示其它内容?</p><ol><li><p>通过传递属性控制(不推荐)<br>这里就不做展示了,因为比较容易想到思路且代码比较冗余</p></li><li><p>法1:通过css</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">wxml中:  &lt;view class&#x3D;&quot;slot-wrapper&quot;&gt;    &lt;view class&#x3D;&quot;slot&quot; &gt; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;view&gt;     &lt;view clas&#x3D;&quot;default&quot; &gt; 展示默认内容 &lt;&#x2F;view&gt;  &lt;&#x2F;view&gt;wxss中:  &#x2F;&#x2F; 思路: 通过非空选择器判断元素是否存在之后兄弟选择器进行配置显隐  &#x2F;&#x2F; 注意: 兄弟选择器只能选择同级下方的属性,所以要注意dom结构  .slot-wrapper .slot:empty+.default&#123;    display: flex;  &#125;   .slot-wrapper .slot&#123;     display: none;     justify-content:center;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h2 id="behaviors-混入"><a href="#behaviors-混入" class="headerlink" title="behaviors(混入)"></a>behaviors(混入)</h2><ol><li>用法类似于vue的Mixin<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">const behaviorsOne &#x3D; require(&#39;behaviorsOne&#39;)Component(&#123;   behaviors:[ behaviorsOne ]&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <strong>值得注意:</strong><br>    (1) 这是组件专有的属性<br>    (2) 如果组件中有同名变量,组件中的变量会覆盖behaviors里的变量,如果变量是引用类型,则会进行合并<br>    (3) behaviors里的生命周期快于组件里的生命周期,如果一个behaviors文件被一个组件引用多次,那么只会执行一次该生命周期函数</p>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の页面App生命周期&amp;路由传参</title>
    <link href="/2022/03/04/miniProgram/basic-03/"/>
    <url>/2022/03/04/miniProgram/basic-03/</url>
    
    <content type="html"><![CDATA[<h2 id="App生命周期"><a href="#App生命周期" class="headerlink" title="App生命周期"></a>App生命周期</h2><table><thead><tr><th>属性</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>onLaunch</td><td>监听小程序初始化</td><td>应用第一次启动就会触发的事件(一般用做程序启动获取用户的个人信息)[比onShow先触发]</td></tr><tr><td>onShow</td><td>监听小程序启动或切前台</td><td>应用被用户看到时触发,比onLaunch慢,会频繁触发[重置应用的数据和页面效果]</td></tr><tr><td>onHide</td><td>监听小程序切后台</td><td>应用被隐藏[暂停或清除定时器,减少内存]</td></tr><tr><td>onError</td><td>错误监听函数</td><td>应用代码发生报错会触[收集用户的错误信息,通过异步请求将错误的信息发送到后台]</td></tr><tr><td>onPageNotFound</td><td>页面不存在监听函数</td><td>应用第一次启动的时候,如果找不到第一个入口页面,才会触发[如果首页找不到了,重新跳到第二个首页]</td></tr></tbody></table><h2 id="Page生命周期"><a href="#Page生命周期" class="headerlink" title="Page生命周期"></a>Page生命周期</h2><table><thead><tr><th>属性</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td>onLoad</td><td>监听页面加载</td><td>发送异步请求来初始化页面数据(页面加载时第一个调用)</td></tr><tr><td>onShow</td><td>监听页面显示</td><td>页面加载时第二个调用</td></tr><tr><td>onReady</td><td>监听页面初次渲染完成</td><td>页面加载时第三个调用</td></tr><tr><td>onHide</td><td>监听页面隐藏</td><td></td></tr><tr><td>onUnload</td><td>监听页面卸载</td><td></td></tr><tr><td>onPullDownRefresh</td><td>监听用户下拉动作</td><td>页面数据和样式初始化,需要配置 “enablePullDownRefresh”: true</td></tr><tr><td>onReachBottom</td><td>页面上拉触底事件的处理函数</td><td>上拉加载下一页数据</td></tr><tr><td>onShareAppMessage</td><td>用户点击右上角转发</td><td></td></tr><tr><td>onPageScroll</td><td>页面滚动触发事件的处理函数</td><td>小程序横屏竖屏切换时触发 [需要在json文件中配置 “pageOrientation”:”auto”]开启横竖屏切换</td></tr><tr><td>onResize</td><td>页面尺寸改变时触发</td><td></td></tr><tr><td>onTabItemTap</td><td>当前是tab页,点击tab时触发</td><td></td></tr></tbody></table><h2 id="路由传参和参数获取"><a href="#路由传参和参数获取" class="headerlink" title="路由传参和参数获取"></a>路由传参和参数获取</h2><p>  场景: 微信小程序的路由跳转方式分为两种: 1) 组件跳转 2) API跳转</p><ol><li><p>组件跳转时传参</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过拼接url参数进行组件传参 target-&gt; 在小程序内跳转&#x2F;&#x2F; 注意点: 不能通过es6的模板字符串进行拼接,tabBar跳转无法传递参数&lt;navigator target&#x3D;&quot;self&quot; url&#x3D;&#39;&#x2F;packagePlayer&#x2F;pages&#x2F;music-player&#x2F;index?id&#x3D;&#123;&#123;id&#125;&#125;&#39; &gt;&lt;&#x2F;navigator&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li><li><p>API跳转</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;button catchtap&#x3D;&quot;onJumpUrl&quot;&gt;跳转&lt;&#x2F;button&gt;Page(&#123;  onJumpUrl(e)&#123;    &#x2F;&#x2F; API调用因为是写在js里的,可以使用ES6的模板字符串    wx.navigateTo(&#123;      url: &#96;&#x2F;packagePlayer&#x2F;pages&#x2F;music-player&#x2F;index?id&#x3D;$&#123;this.data.id&#125;&#96;,    &#125;);  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <strong>注意</strong>: 微信小程序是多种路由跳转方式的,但是传参基本一致,这里为了演示如何拼接参数只使用了部分API(组件跳转可以在<code>open-type</code>中设置跳转属性)</p><ol start="3"><li>路由参数获取<ol><li><p>生命周期获取<br>定义: 在Page的onLoad生命周期可以通过options参数获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Page(&#123;  onLoad(options)&#123;    const &#123; id &#125; &#x3D; options  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>API获取</p><div class="code-wrapper"><pre><code>let pages = getCurrentPages();     // 获取跳转页面的信息数组let currentPages = pages[pages.length - 1]    // 每次都取上一个页面的信息let options = currentPages.options    // 通过options里获取参数const &#123; goods_id &#125; = optionsthis.getGoodsDetails(goods_id)</code></pre></div></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の组件使用</title>
    <link href="/2022/03/03/miniProgram/basic-02/"/>
    <url>/2022/03/03/miniProgram/basic-02/</url>
    
    <content type="html"><![CDATA[<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><ol><li><p>注册自定义组件</p><ol><li>在微信开发者工具中,选择components文件夹鼠标右击选择新建component,输入名称后自动创建4个文件,基本与page页面结构相同</li><li>在需要使用组件的页面文件或者组件文件,选择.json结尾的配置文件</li><li>在json文件中的”usingCompoents”属性中进行配置<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;usingComponents&quot;: &quot;需要引入的组件路径&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></li></ol></li><li><p>使用第三方组件库(vantUI)<br>详情见: <a href="https://vant-contrib.gitee.io/vant-weapp/#/quickstart">https://vant-contrib.gitee.io/vant-weapp/#/quickstart</a></p></li></ol><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><ol><li><p>父组件通信子组件</p>   <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">父组件中:   &lt;child-comp value&#x3D;&quot;&#123;&#123; num &#125;&#125;&quot;&gt;&lt;&#x2F;child-comp&gt;  Page(&#123;    data:&#123;      num: 1    &#125;  &#125;)子组件中:  &lt;view&gt; &#123;&#123; value &#125;&#125; &lt;&#x2F;view&gt;  --&gt; 显示为1  Component(&#123;    properties:&#123;      value:&#123;       type: Number,       value: 0      &#125;    &#125;,    lifetimes:&#123;      ready()&#123;       console.log(  this.properties.value ) --&gt; 0      &#125;    &#125;  &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>   <strong>注意</strong>: </p><div class="code-wrapper"><pre><code> (1) 也可以通过子组件的data获取在properties定义的值,因为在子组件接收父组件传递的参数后,data会拷贝一份properties的值,但是不推荐使用data里的值,容易造成代码混淆 (2) 不能直接使用setData去修改propertie中定义的参数,必须使用子组件通信父组件的方式改变值</code></pre></div></li><li><p>子组件通信父组件</p>   <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">父组件中:    &#x2F;&#x2F; 首先绑定自定义事件用来接收子组件传递的参数    &lt;view bindgetChildValue&#x3D;&quot;getValue&quot;&gt;&lt;&#x2F;view&gt;    Page(&#123;      getValue(e)&#123;        &#x2F;&#x2F; 在e.detail中接收子组件传递的参数,key名为value        console.log(e.detail.value)      &#125;    &#125;)子组件中:  &#x2F;&#x2F; 使用全局定义的方法 this.triggleEvent(&#39;父组件自定义事件名称&#39;, 子组件需要传递的参数)  &lt;button catchtap&#x3D;&quot;passValue&quot; data-item&#x3D;&quot;2&quot; &gt;点击传参&lt;&#x2F;button&gt;  Component(&#123;    data:&#123;      num : 2    &#125;,    methods:&#123;      passValue(e)&#123;        const &#123; item &#125; &#x3D; e.currentTarget.dataset        this.triggerEvent(&#39;getChildValue&#39;,&#123; num:this.data.num ,item  &#125;)      &#125;    &#125;  &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><ol><li><p><strong>组件的生命周期最好定义在lifetimes属性中</strong></p>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Component(&#123;  lifetimes:&#123;    ready()&#123;&#125;  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>组件生命周期</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>created</td><td>组件刚刚被创建,不能使用setData</td></tr><tr><td>attached</td><td>组件实例进入页面节点树执行</td></tr><tr><td>ready（常用）</td><td>组件布局完成后执行</td></tr><tr><td>moved</td><td>组件实例被移动到节点树另一个位置时执行</td></tr><tr><td>detached</td><td>组件实例被从页面节点树移除时执行</td></tr></tbody></table></li></ol><h2 id="observers-监听属性"><a href="#observers-监听属性" class="headerlink" title="observers(监听属性)"></a>observers(监听属性)</h2><ol><li>定义:<br>小程序组件独有的属性。数据监听器支持监听属性(properties)或内部数据(data)的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。</li><li>使用: <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">(1) 对象&#x2F;数组单层监听  data:&#123;    arr:[1,2,3]    obj:&#123; a:1 , b:2&#125;  &#125;,  observers:&#123;    &#39;arr[1]&#39;(newval)&#123;&#125;,    &#39;obj.a&#39;(newval)&#123;&#125;  &#125;(2) 多个变量同时监听  data:&#123;    num1: 1,    num2: 2,    sum:0  &#125;  observers:&#123;    &#39;num1,num2&#39;(numbers1,numbers2)&#123;      this.setData(&#123;        sum &#x3D; numbers1 + numbers2      &#125;)    &#125;  &#125; (3) 监听所有子数据的变量变化 定义: 通过通配符** data:&#123;    obj:&#123;       child:&#123;          a:1,                          b:2      &#125;    &#125;  &#125;,  observers:&#123;    &#39;obj.child.**&#39;(newval)&#123;      newval &#x3D;&#x3D;&#x3D; this.data.obj.child    &#125;  &#125; (4) 可以直接监听**,即监听所有数据的变化  observers:&#123;    &#39;**&#39;(newval)&#123;      &#x2F;&#x2F; newval &#x3D; &#123;...this.data,...this.properties&#125;    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小程序の基础语法</title>
    <link href="/2022/03/03/miniProgram/basic-01/"/>
    <url>/2022/03/03/miniProgram/basic-01/</url>
    
    <content type="html"><![CDATA[<h2 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h2><ol><li>初识微信小程序插值语法<br>定义: 类似于vue的插值语法,也采用<code>&#123;&#123; &#125;&#125;</code>进行值的动态绑定<br>值的注意:  <div class="code-wrapper"><pre><code> (1) 无法像vue语法中可以进行函数调用 (2) 传递布尔值值必须使用&#123;&#123;&#125;&#125;传递,不使用&#123;&#123;&#125;&#125;默认都是字符串,false就会被编译成字符串false,显示为true</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;view&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;view&gt; --&gt; 页面显示: Nano&lt;view&gt;&#123;&#123;change(name)&#125;&#125;&lt;&#x2F;view&gt; --&gt; 页面无法显示Page(&#123;  data:&#123;    name : &#39;Nano&#39;  &#125;,  change()&#123;&#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>动态值的绑定<br>定义: 用于在样式、微信指令和传参时值的动态绑定<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1) 样式的绑定   class:      &lt;view class&#x3D;&quot;bg-color &#123;&#123; isShow ?&#39;ft-color&#39;:&#39;&#39; &#125;&#125;&quot;&gt;&lt;&#x2F;view&gt;   style:      &lt;view style&#x3D;&quot;padding-top:&#123;&#123; pdTop &#125;&#125;px&quot;&gt;&lt;&#x2F;view&gt;          Page(&#123;      data:&#123;        isShow : true ,        pdTop :36      &#125;    &#125;)2) 微信指令的参数绑定    wx:if&#x2F;wx:elif&#x2F;wx:else&#x2F;wx:for :      &lt;view wx:if&#x3D;&quot;&#123;&#123; item &#x3D;&#x3D;&#x3D; 1&#125;&#125;&quot;&gt;1&lt;&#x2F;view&gt;      &lt;view wx:elif&#x3D;&quot;&#123;&#123; item &#x3D;&#x3D;&#x3D; 2&#125;&#125;&quot;&gt;2&lt;&#x2F;view&gt;      &lt;view wx:else&gt;3&lt;&#x2F;view&gt;      &lt;view wx:for&#x3D;&quot;&#123;&#123;arr&#125;&#125;&quot; :key&#x3D;&quot;ind&quot; wx:for-item&#x3D;&quot;itm&quot; wx:for-index&#x3D;&quot;ind&quot;&gt;&#123;&#123; itm &#125;&#125;&lt;&#x2F;view&gt;      Page(&#123;        data:&#123;          item : 1 ,          arr : [1, 2, 3]        &#125;      &#125;)3) 组件动态传参   父组件:    &lt;Child item&#x3D;&quot;&#123;&#123; type &#125;&#125;&quot;&gt;&lt;&#x2F;Child&gt;    Page(&#123;      data:&#123;        type : 1      &#125;    &#125;)   json文件:      &quot;usingComponents&quot; : &#123;        &quot;Child&quot; : 路径      &#125;   子组件:    &lt;view&gt; &#123;&#123; type &#125;&#125; &lt;&#x2F;view&gt;    Component(&#123;      properties:&#123;        type: Number,        value: 0      &#125;    &#125;)4) 配合方法传参:   前言: 配合方法动态传参一般在wx:for循环时出现比较多   &lt;block wx:for&#x3D;&quot;&#123;&#123; row &#125;&#125;&quot; wx:key&#x3D;&quot;index&quot; wx:for-item&#x3D;&quot;item&quot;&gt;      &lt;button catchtap&#x3D;&quot;handlePassRow&quot; data-row&#x3D;&quot;&#123;&#123;item&#125;&#125;&quot;&gt;打印数据&lt;&#x2F;button&gt;   &lt;&#x2F;block&gt;   Page(&#123;     data:&#123;       row:[         &#123; index:1 &#125;       ]     &#125;,     handlePassRow(e)&#123;       &#x2F;&#x2F; 小程序固定语法,从e.currentTarget.dataset 获取       const &#123; row &#125; &#x3D; e.currentTarget.dataset       console.log( row )  --&gt; &#123; index: 1 &#125;     &#125;   &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h2 id="事件绑定语法"><a href="#事件绑定语法" class="headerlink" title="事件绑定语法"></a>事件绑定语法</h2><ol><li>小程序的方法绑定分为 bind 和catch<ol><li>区别:<br>前言: 在小程序中,不支持通过js原生的<code>e.stopProgaration</code>进行阻止事件冒泡<br><strong>bind无法阻止事件冒泡,而catch可以</strong></li><li>绑定示例:<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; bind&#x2F;catch:tap 和 bind&#x2F;catchtap 性质是一样的  &lt;button bind:tap&#x3D;&quot;tapClick&quot;&gt; bind点击事件 &lt;button&gt;&lt;button catch:tap&#x3D;&quot;catchClick&quot;&gt; catch点击事件 &lt;button&gt;&#x2F;&#x2F; 用于子组件与父组件通信使用&lt;button bindselfAtion&#x3D;&quot;selfAction&quot;&gt; 绑定自定义事件点击 &lt;button&gt;&#x2F;&#x2F; 在page页面和component中方法存放的位置略有不同page: 与data平级  data:&#123;&#125;,  tapClick(e)&#123;&#125;component: 存放在methods中  data:&#123;&#125;  methods:&#123;    tapClick(e)&#123;&#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h2 id="事件event参数和setData"><a href="#事件event参数和setData" class="headerlink" title="事件event参数和setData()"></a>事件event参数和setData()</h2><ol><li><p>小程序通过bind/catch绑定的语法都通过event参数获取需要事件信息,类似于原生事件的event参数</p><ol><li><p>如何获取传递的参数?<br>表单元素获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;input bindinput&#x3D;&quot;onInput&quot; &#x2F;&gt;Page(&#123;  &#x2F;&#x2F; 表单元素获取是在e.currentTarget.detail中获取,固定key值为value  onInput(e)&#123;     const &#123; value &#125; &#x3D; e.currentTarget.detail  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>非表单元素获取</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;view bindtap&#x3D;&quot;onClick&quot; data-item&#x3D;&quot;1&quot;&gt;&lt;&#x2F;view&gt;Page(&#123;  &#x2F;&#x2F; 表单元素获取是在e.currentTarget.dataset中获取,固定key值为data-后面绑定的key值  onClick(e)&#123;     const &#123; item &#125; &#x3D; e.currentTarget.dataset --&gt; 1  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>值的注意:<br>  <strong>当子组件与父组件进行传参通信时,是通过e.currentTarget.detail获取的参数</strong>,也就是说dataset存储的一般都是自定义绑定的参数值,而detail里传递的参数是表单值或者子组件通信传递来的值</p></li></ol></li><li><p>e.currentTarget和e.target的区别<br> e.currentTarget 指向的是触发事件监听的对象<br> e.target 指向的是添加（注册）监听事件的对象<br> 如果没有发生元素嵌套,那么 e.currentTarget和e.target是一样的<br> <strong>一般我们在小程序里,一般都采用e.currentTarget防止不可控的错误发生</strong></p></li><li><p>setData()<br>定义: setData()是用来响应式更新页面绑定的data中的值的内置共用方法<br>执行时机:<br>   在执行赋值操作时是同步的<br>   在执行页面渲染时是异步的</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;view&gt; &#123;&#123; num &#125;&#125; &lt;&#x2F;view&gt;&lt;button catchtap&#x3D;&quot;onAdd&quot;&gt; add &lt;&#x2F;button&gt;Page(&#123;  data:&#123;    num:0  &#125;,  onAdd(e)&#123;    let num &#x3D; this.data.num++    this.setData(&#123;      num    &#125;)  &#125;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>微信小程序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置Valine评论系统</title>
    <link href="/2021/12/15/hexo/hexoComment/"/>
    <url>/2021/12/15/hexo/hexoComment/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="code-wrapper"><pre><code>本文主要用来介绍如何在Fluid主题中博客添加Valine评论系统</code></pre></div><h3 id="Valine优点"><a href="#Valine优点" class="headerlink" title="Valine优点"></a>Valine优点</h3><p>其实Fluid主题内置了很多评论插件,比如<code>utterances</code>,<code>valine</code>等等,选择valine的原因如下:</p><ul><li><p>无后端实现</p></li><li><p>高速，使用国内后端云服务提供商 LeanCloud 提供的存储服务</p></li><li><p>开源，自定义程度高</p></li><li><p>支持邮件通知</p></li><li><p>支持验证码</p></li><li><p>支持 Markdown</p></li></ul><h3 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h3><ol><li>注册Leancloud</li></ol><p>Valine作为一款第三方的评论系统，评论数据都储存在Leancloud上，所以第一步我们要去 leancloud官网：<a href="https://www.leancloud.cn/">https://www.leancloud.cn/</a> 注册一个账户，注册完成后现在需要实名认证后才可以创建应用<br><img src="/img/fluid-comment.png" alt="注册并实名Leancloud账号" title="注册并实名Leancloud账号"><br>2. 创建应用</p><p><img src="/img/fluid-comment-2.png" alt="创建应用" title="创建应用"></p><p><img src="/img/fluid-comment-3.png" alt="创建应用" title="创建应用"></p><ol start="3"><li>配置应用</li></ol><p><img src="/img/fluid-comment-4.png" alt="配置应用" title="配置应用"></p><p><img src="/img/fluid-comment-5.png" alt="配置应用" title="配置应用"></p><p><img src="/img/fluid-comment-6.png" alt="配置应用" title="配置应用"></p><ol start="4"><li><p>配置_config.fluid.yml</p><ol><li><p>在文件中查找<code>Comments</code>关键字,进行下面配置</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 评论插件# Comment plugincomments:    enable: true    # 指定的插件，需要同时设置对应插件的必要参数    # The specified plugin needs to set the necessary parameters at the same time    # Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis    type: valine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>在文件中查找<code>valine</code>关键字,进行下面配置</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">valine:appId: 填写刚才在Leancloud创建的应用的appIdappKey: 填写刚才在Leancloud创建的应用的appKeypath: window.location.pathname # 当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表placeholder:  吐槽一哈!!!! # 占位符avatar: &#39;retro&#39; # Gravatar 头像展示方式meta: [&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]  # 评论者相关属性requiredFields: []pageSize: 10 # 评论列表分页，每页条数lang: &#39;zh-CN&#39; # zh-CN | zh-TW | en | jahighlight: false # 代码是否高亮recordIP: false # 是否记录评论者IPserverURLs: &#39;&#39; # REST API 服务器地址，国际版不填emojiCDN:emojiMaps:enableQQ: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li></ol><h3 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h3><div class="code-wrapper"><pre><code>配置完成之后重启hexo,就可以看到效果~</code></pre></div><p><img src="/img/fluid-comment-7.png" alt="完成配置" title="完成配置"></p><h3 id="删除评论数据"><a href="#删除评论数据" class="headerlink" title="删除评论数据"></a>删除评论数据</h3><p><img src="/img/fluid-comment-8.png" alt="删除评论数据" title="删除评论数据"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>hexo主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题配置</title>
    <link href="/2021/12/15/hexo/fluidOptions/"/>
    <url>/2021/12/15/hexo/fluidOptions/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class="code-wrapper"><pre><code>之前介绍了如何使用Fluid的主题,这篇将继续深入如何去使用Fluid。</code></pre></div><h3 id="基础目录结构"><a href="#基础目录结构" class="headerlink" title="基础目录结构"></a>基础目录结构</h3><ol><li>使用<code>hexo n 文件名称</code>创建一个md文档,用来创作博客文章,进入md文档后,基础结构展示如下: <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">---title: 使用Hexo搭建博客（基础版） # 博客文章标题date: 2021-12-15 01:47:44  # 文章编写日期index_img: &#x2F;img&#x2F;fluid-hexo.png # 缩略图categories:- hexo博客搭建 # 分类tags: # 标签- hexo- github---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><h3 id="常用基础配置"><a href="#常用基础配置" class="headerlink" title="常用基础配置"></a>常用基础配置</h3><p>Flui主题自身内置了很多插件,当我们想美化自己的博客时,可以在<code>_config.fluid.yml</code>文件下,通过一些配置去实现,非常的简便。接下来就介绍一些常用配置的设置</p><ol><li><p>favicon<br> 通过设置<code>favicon</code>和<code>apple_touch_icon</code>来设置浏览器标签图标,可以使用连接资源,也可以使用本地资源路径</p><p> <img src="/img/fluid-options-1.png" alt="fluid主题设置" title="fluid主题设置"></p><p> <img src="/img/fluid-options-2.png" alt="fluid主题设置" title="fluid主题设置"></p></li><li><p>打字机效果</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">fun_features:# 为 subtitle 添加打字机效果# Typing animation for subtitletyping:    enable: true# 打印速度，数字越大越慢# Typing speed, the larger the number, the slower    typeSpeed: 70# 游标字符# Cursor character    cursorChar: &quot;_&quot;# 是否循环播放效果# If true, loop animation    loop: false# 为文章内容中的标题添加锚图标 # Add an anchor icon to the title on the post page<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>颜色的修改</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">color:    # body 背景色    # Color of body background    body_bg_color: &quot;#eee&quot;    # 暗色模式下的 body 背景色，下同    # Color in dark mode, the same below    body_bg_color_dark: &quot;#181c27&quot;    # 顶部菜单背景色    # Color of navigation bar background    navbar_bg_color: &quot;#2f4154&quot;    navbar_bg_color_dark: &quot;#1f3144&quot;    # 顶部菜单字体色    # Color of navigation bar text    navbar_text_color: &quot;#fff&quot;    navbar_text_color_dark: &quot;#d0d0d0&quot;    # 全局字体色    # Color of global text    text_color: &quot;#3c4858&quot;    text_color_dark: &quot;#c4c6c9&quot;    # 全局次级字体色（摘要、简介等位置）    # Color of global secondary text (excerpt, introduction, etc.)    sec_text_color: &quot;#718096&quot;    sec_text_color_dark: &quot;#a7a9ad&quot;    # 文章正文字体色    # Color of post text    post_text_color: &quot;#2c3e50&quot;    post_text_color_dark: &quot;#c4c6c9&quot;    # 文章正文字体色（h1 h2 h3...）    # Color of Article heading (h1 h2 h3...)    post_heading_color: &quot;#1a202c&quot;    post_heading_color_dark: &quot;#c4c6c9&quot;    # 文章超链接字体色    # Color of post link    post_link_color: &quot;#0366d6&quot;    post_link_color_dark: &quot;#1589e9&quot;    # 超链接悬浮时字体色    # Color of link when hovering    link_hover_color: &quot;#30a9de&quot;    link_hover_color_dark: &quot;#30a9de&quot;    # 超链接悬浮背景色    # Color of link background when hovering    link_hover_bg_color: &quot;#f8f9fa&quot;    link_hover_bg_color_dark: &quot;#364151&quot;    # 主面板背景色    # Color of main board    board_color: &quot;#fff&quot;    board_color_dark: &quot;#252d38&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>搜索功能</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 搜索功能，基于 hexo-generator-search 插件，若已安装其他搜索插件请关闭此功能，以避免生成多余的索引文件# Search feature, based on hexo-generator-search. If you have installed other search plugins, please disable this feature to avoid generating redundant index filessearch:    enable: true  # 将这个打开就可以实现站内搜索,默认自动打开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>footer</p> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">footer:# 页脚第一行文字的 HTML，建议保留 Fluid 的链接，用于向更多人推广本主题# HTML of the first line of the footer, it is recommended to keep the Fluid link to promote this theme to more peoplecontent: &#39;&lt;div&gt;这里用来设置页面底部文字展示,支持HTML&lt;&#x2F;div&gt;&#39;# 展示网站的 PV、UV 统计数# Display website PV and UV statisticsstatistics:    enable: true# 统计数据来源，使用 leancloud 需要设置 &#96;web_analytics: leancloud&#96; 中的参数；使用 busuanzi 不需要额外设置，但是有时不稳定，另外本地运行时 busuanzi 显示统计数据很大属于正常现象，部署后会正常# Data source. If use leancloud, you need to set the parameter in &#96;web_analytics: leancloud&#96;# Options: busuanzi | leancloudsource: &quot;busuanzi&quot;# 页面显示的文本，&#123;&#125;是数字的占位符（必须包含)，下同# Displayed text, &#123;&#125; is a placeholder for numbers (must be included), the same belowpv_format: &quot;总访问量 &#123;&#125; 次&quot;uv_format: &quot;总访客数 &#123;&#125; 人&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="config-yml的一些设置"><a href="#config-yml的一些设置" class="headerlink" title="_config.yml的一些设置"></a>_config.yml的一些设置</h3> <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># Sitetitle: 博客主题名称subtitle: &#39;副标题&#39;description: &#39;博客描述&#39;keywords: &#39;搜索关键词&#39;author: 作者名称language: zh-CN  # 语言timezone: &#39;Asia&#x2F;Shanghai&#39;   # 时区设置   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果需要更换banner图片却又找不到合适的图片该怎么办?<br>兄弟莫慌~<br>附上官方链接: <a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>hexo主题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于gitee的PicGo的搭建</title>
    <link href="/2021/12/13/hexo/picGo/"/>
    <url>/2021/12/13/hexo/picGo/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>  想着做一个图床,方便博客的图片管理以及减少静态资源的占用量</p><h3 id="PicGo介绍"><a href="#PicGo介绍" class="headerlink" title="PicGo介绍"></a>PicGo介绍</h3><blockquote><p>一个用于快速上传图片并获取图片 URL 链接的工具</p></blockquote><ul><li>支持拖拽图片上传</li><li>支持快捷键上传剪贴板里第一张图片</li><li>Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)</li><li>上传图片后自动复制链接到剪贴板</li><li>支持自定义复制到剪贴板的链接格式</li><li>支持修改快捷键，默认快速上传快捷键：command+shift+p（macOS）| control+shift+p（Windows\Linux)</li><li>支持插件系统，已有插件支持 Gitee、青云等第三方图床</li><li>更多第三方插件。</li><li>支持通过发送 HTTP 请求调用 PicGo 上传（v2.2.0+)</li></ul><h3 id="准备搭建"><a href="#准备搭建" class="headerlink" title="准备搭建"></a>准备搭建</h3><blockquote><p>环境准备: </p></blockquote><ul><li><a href="https://git-scm.com/">git</a></li><li><a href="https://gitee.com/">gitee</a></li><li><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></li></ul><h3 id="Gitee准备"><a href="#Gitee准备" class="headerlink" title="Gitee准备"></a>Gitee准备</h3><ol><li>注册<a href="https://gitee.com/login">gitee</a>账号(默认都安装了git,这里就不介绍了)  </li></ol><p><img src="/img/gitee-login-1.png" alt="gitee注册界面" title="gitee注册步骤一"><br><img src="/img/gitee-login-2.png" alt="gitee注册界面" title="gitee注册步骤二"><br><img src="/img/gitee-login-3.png" alt="gitee注册界面" title="gitee注册步骤三"></p><ol start="2"><li>创建仓库</li></ol><p><img src="/img/gitee-create-store-1.png" alt="gitee新建仓库界面" title="gitee新建仓库步骤一"><br><img src="/img/gitee-create-store-2.png" alt="gitee新建仓库界面" title="gitee新建仓库步骤二"></p><ol start="3"><li>配置私人令牌</li></ol><p><img src="/img/gitee-picgo-set-1.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤一"><br><img src="/img/gitee-picgo-set-2.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤二"><br><img src="/img/gitee-picgo-set-3.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤三"><br><img src="/img/gitee-picgo-set-4.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤四"><br><img src="/img/gitee-picgo-set-5.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤五"><br><img src="/img/gitee-picgo-set-6.png" alt="gitee配置私人令牌" title="gitee配置私人令牌步骤六"></p><h3 id="PicGo准备"><a href="#PicGo准备" class="headerlink" title="PicGo准备"></a>PicGo准备</h3><ol><li>点击进入下载地址连接(<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a>)</li></ol><p><img src="/img/picgo-pack.png" alt="下载对应的PicGo安装包" title="下载对应的PicGo安装包"></p><blockquote><p><strong>Tips:</strong> 选择对应的下载版本,建议不要用beta版本</p></blockquote><ol start="2"><li><p><strong>下载成功后一直下一步安装即可。</strong></p></li><li><p>PicGo配置( <strong>安装成功后</strong>)</p></li></ol><p><img src="/img/picgo-setting-1.png" alt="PicGo配置" title="PicGo配置步骤一"><br><img src="/img/picgo-setting-2.png" alt="PicGo配置" title="PicGo配置步骤二"><br><img src="/img/picgo-setting-3.png" alt="PicGo配置" title="PicGo配置步骤三"><br><img src="/img/picgo-setting-4.png" alt="PicGo配置" title="PicGo配置步骤四"><br><img src="/img/picgo-setting-5.png" alt="PicGo配置" title="PicGo配置步骤五"><br><img src="/img/picgo-setting-6.png" alt="PicGo配置" title="PicGo配置步骤六"><br><img src="/img/picgo-setting-7.png" alt="PicGo配置" title="PicGo配置步骤七"><br><img src="/img/picgo-setting-8.png" alt="PicGo配置" title="PicGo配置步骤八"></p><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><blockquote><p>示例链接: <a href="https://gitee.com/roily/test-pic-bed/raw/master/img/test033.png">https://gitee.com/roily/test-pic-bed/raw/master/img/test033.png</a></p></blockquote><ul><li>一些需要注意的问题:<ol><li>当使用图床的url后,在微信打开无法显示,应该是微信做了某些限制,手机浏览器和钉钉内部打开是可以的。<br><img src="/img/picgo-waring.jpg" alt="PicGo问题" title="PicGo问题"></li><li>为什么不使用github做为图床仓库?<br>因为github在国内访问速度较慢,所以没有考虑,github也是可以做图床的。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>picGo</tag>
      
      <tag>gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid配置使用</title>
    <link href="/2021/12/10/hexo/hexoFluid/"/>
    <url>/2021/12/10/hexo/hexoFluid/</url>
    
    <content type="html"><![CDATA[<h3 id="Fluid介绍"><a href="#Fluid介绍" class="headerlink" title="Fluid介绍"></a>Fluid介绍</h3><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> 是基于 Hexo 的一款 Material Design 风格的主题</p><ul><li><p>优势<br>1.设计遵循简洁至上，同时具有轻快的体验，和优雅的颜值；<br>2.提供大量定制化配置项，使每个用户使用该主题都能具有独特的样式；<br>3.响应式页面，适配手机、平板等设备；<br>4.为数不多内置支持 LaTeX 语法公式的主题。</p></li><li><p>特性<br>1.图片懒加载<br>2.自定义代码高亮方案<br>3.内置多语言<br>4.内置多款评论插件<br>5.外部覆盖配置<br>6.静态资源配置<br>7.文章搜索<br>8.页脚备案信息<br>9.网页访问统计<br>10.支持 LaTeX 数学公式<br>11.音乐播放器</p><blockquote><p><strong>Tips:</strong><br>  Fluid主题github仓库<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a><br>  hexo还有很多主题,具体可以查看<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p></blockquote><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3></li><li><p>方法1(推荐): Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令</p><ol><li><p>输入指令</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">npm install --save hexo-theme-fluid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><img src="/img/fuild-save.png" alt="Fluid版本下载" title="Fluid版本下载"></p></li><li><p>在与<code>_config.yml</code>文件平级的目录下,新建文件<code>_config.fluid.yml</code><br><img src="/img/fuild-create-1.png" alt="创建Fluid配置文件" title="创建Fluid配置文件"></p></li><li><p>创建文件后,打开Fluid的github仓库地址: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a>,进入仓库后点击打开Fluid仓库中的<code>_config.yml</code>文件<br><img src="/img/Fluid-Change-1.png" alt="打开_config.yml文件" title="打开_config.yml文件"></p></li><li><p>打开后,复制全部代码,粘贴入刚才创建的<code>_config.fluid.yml</code>文件中<br><img src="/img/Fluid-Change-2.png" alt="复制_config.yml文件" title="复制config.yml文件"></p></li><li><p>粘贴成功后,点击<code>_config.yml</code>文件,点击搜索<code>theme</code>关键字,将之前的默认主题landscape换成<code>fluid</code><br><img src="/img/Fluid-Change-3.png" alt="更换fluid主题" title="更换fluid主题"></p></li></ol><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">最后执行:    hexo g    hexo s    就可以本地运行打开查看已经配置好的fluid主题~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p><img src="/img/Fluid-Change-4.png" alt="完成更换fluid主题" title="完成更换fluid主题"></p></li><li><p>方法2:</p><ol><li>进入github仓库下载最新 release 版本解压到themes目录并将解压出的文件夹重命名为 fluid，最后将整个fluid拷贝至脚手架的themes文件夹内</li></ol><p>  <img src="/img/fluid-action2-1.png" alt="下载最新release压缩包" title="下载最新release压缩包"></p><p>  <img src="/img/fluid-action2-2.png" alt="重命名release压缩包" title="重命名release压缩包"></p><p>  <img src="/img/fluid-action2-3.png" alt="放置release压缩包" title="放置release压缩包"></p><ol start="2"><li>完成后同样需要将<code>_config.yml</code>文件的<code>theme</code>关键字,更换成<code>fluid</code><br><img src="/img/Fluid-Change-3.png" alt="更换fluid主题" title="更换fluid主题"><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">最后执行:  hexo g  hexo s  同方法1一样可以本地运行打开查看已经配置好的fluid主题~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol><p>  <img src="/img/Fluid-Change-4.png" alt="完成更换fluid主题" title="完成更换fluid主题"></p></li></ul><h3 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h3><blockquote><p>在使用方法2完成了主题更换的前提下,我们之后如果要在主题上进行修改,每次修改都需要到/themes/fluid下修改主题的<code>_config.yml</code>文件，这样特别麻烦，并且在版本更新时，都要注意怕被新的<code>_config.yml</code>文件替换掉，又回滚到了初始的代码，所以官方也建议将主题的<code>_config.yml</code>文件复制一份重命名为<code>_config.fluid.yml</code>文件到Hexo脚手架的根目录下，和<code>_config.yml</code>文件并列。这样，在官方更新版本时，直接覆盖.themes/fluid下的文件就可以了，不会影响到<code>_config.fluid.yml</code>文件</p></blockquote><p>  <img src="/img/fluid-action2-4.png" alt="备份fluid主题文件" title="备份fluid主题文件"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid</tag>
      
      <tag>hexo主题</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vueの修饰符</title>
    <link href="/2021/11/18/Vue/keyModifier/"/>
    <url>/2021/11/18/Vue/keyModifier/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>本篇文章是专门用来介绍vue的修饰符</li><li>包括了<strong>指令的修饰符</strong>,<strong>事件修饰符</strong>,<strong>按键修饰符</strong>,<strong>其它修饰符</strong></li><li>了解常用的修饰符,使某些场景的开发变得更加简便</li></ul><h3 id="指令的修饰符"><a href="#指令的修饰符" class="headerlink" title="指令的修饰符"></a>指令的修饰符</h3><p>简介: 指令的修饰符包括了<code>v-model</code>的修饰符和<code>v-bind</code>的修饰符,这些都是一些比较常用的修饰符,有便于我们平常的开发</p><ul><li><p>v-model的修饰符<br>  <code>v-model</code>的修饰符分为3种<code>.lazy,.trim,.number</code></p><ol><li><strong>.lazy</strong><blockquote><p><code>v-model</code>在添加了<code>.lazy</code>修饰符之后只有等输入框失去焦点之后或者按下enter键才会显示输入的内容</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;input v-model.lazy&#x3D;&quot;demoText&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;    &lt;h1&gt;&#123;&#123; demoText &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div> <img src="/img/lazy.gif" alt=".lazy示意"></li><li><strong>.trim</strong><blockquote><p><code>.trim</code>修饰符会将双向绑定的内容的首尾空格进行去除,和字符串的<code>trim</code>方法效果是一致的,如果一直输入空格按钮,则绑定的值一直为<code>&#39;&#39;(空字符串)</code>,中间的空格是无法清除的。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &#x2F;&#x2F; 如果输入demoText为 &#39; abc &#39; 则显示为:abc    &#x2F;&#x2F; 如果输入demoText为 &#39;a bc &#39; 则显示为:a bc    &lt;input v-model.trim&#x3D;&quot;demoText&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;    &lt;h1&gt;&#123;&#123; demoText &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><strong>.number</strong><blockquote><p><code>v-model</code>在加了<code>.number</code>修饰符之后,会把输入的数值从字符串或其他类型转换为number类型</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &#x2F;&#x2F; 如果输入demoText为 &#39;&#39;    则 typeText为string    &#x2F;&#x2F; 如果输入demoText为 &#39;123&#39; 则 typeText为number    &lt;input v-model.number&#x3D;&quot;demoText&quot; type&#x3D;&quot;text&quot;&#x2F;&gt;    &lt;h1&gt; &#123;&#123; typeText &#125;&#125; &lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;    import &#123; defineComponent ,ref ,computed&#125; from &#39;vue&#39;    export default defineComponent(&#123;        setup()&#123;            let demoText &#x3D; ref(&#39;&#39;)            let typeText &#x3D; computed(()&#x3D;&gt;&#123;              return typeof demoText.value            &#125;)            return &#123;                demoText,                typeText            &#125;        &#125;    &#125;)&lt;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol></li><li><p>v-bind的修饰符<br><code>v-bind</code>的常用修饰符为<code>.sync</code></p><ol><li><strong>.sync</strong><blockquote><p><code>v-bind</code>的属性名之后添加<code>.sync</code>,可以通过<code>$emit(&#39;update:属性名&#39;, value)</code>实现父子组件的数据双向绑定</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;    &lt;div class&#x3D;&quot;demo&quot;&gt;        &#x2F;*             实际扩展为:            &lt;child-comp :label&#x3D;&quot;label&quot; @update:label&#x3D;&quot;val &#x3D;&gt; label &#x3D; val&quot; &#x2F;&gt;        *&#x2F;        &lt;child-comp :label.sync&#x3D;&quot;label&quot; &#x2F;&gt;        &lt;div&gt;&#123;&#123; label &#125;&#125;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&#x2F;&#x2F; childComp.vue&lt;template&gt;    &lt;div class&#x3D;&quot;demoChild&quot;&gt;        &lt;button @click&#x3D;&quot;$emit(&#39;update:label&#39;,&#39;修改父组件的label&#39;)&quot;&gt;            修改        &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>当点击childComp.vue的button时,父组件的label则会改为 <em>修改父组件的label</em></p></blockquote></li></ol><blockquote><p>值的注意的是,vue3.0已经将<code>.sync</code>修饰符移除,与<code>v-model</code>进行了一个融合<br> <img src="/img/sync.png" alt=".sync修饰符3.0移除">  </p></blockquote></li></ul><h3 id="事件的修饰符"><a href="#事件的修饰符" class="headerlink" title="事件的修饰符"></a>事件的修饰符</h3><p>简介: 针对事件行为设计的修饰符,比如<code>stopPropagation()[阻止冒泡]</code>,<code>preventDefault()[阻止默认行为]</code>等等…</p><ul><li>stop –&gt; event.stopPropagation()阻止事件冒泡<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 阻止单击事件冒泡，当点击box2时就不会触发box1的点击事件，若不加则会触发 --&gt;&lt;div class&#x3D;&quot;box1&quot; @click&#x3D;&quot;btn&quot;&gt;&lt;div class&#x3D;&quot;box2&quot; @click.stop&#x3D;&quot;btn1&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li>prevent -&gt; event.preventDefault(),阻止事件默认行为<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>capture –&gt; 来实现捕获触发事件的机制<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 添加事件侦听器时使用事件捕获模式，先执行外层盒子事件，再执行里面盒子事件 --&gt;&lt;div v-on:click.capture&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>self –&gt; 实现只有点击当前元素时候，才会触发事件处理函数（只会阻止自己身上的冒泡行为，并不会阻止真正的冒泡）<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 只当事件在该元素本身（而不是子元素）才去执行 --&gt;&lt;div v-on:click.self&#x3D;&quot;toDo&quot;&gt;...&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li>once –&gt; 只触发一次处理函数<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;button v-on:click.once&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></li><li>passive –&gt; 对应 addEventListener 中的 passive 选项；表示它不会阻止事件的默认行为(通常来说，滚动页面的默认行为被阻止了，页面必须静止不动，但浏览器无法预先知道一个监听器会不会调用 preventDefault(),只有等滚动监听器执行完再去执行默认行为，而监听器执行是要耗时的，而且80%的滚动监听器是不会阻止默认行为的，所以浏览器白等，passive 监听器诞生了，可以在两个线程里同时执行监听器中的 JavaScript 代码和浏览器的默认行为了。）<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 &#96;onScroll&#96; 完成  --&gt;&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况 --&gt;&lt;div v-on:scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p><strong>.passive 修饰符尤其能够提升移动端的性能</strong><br>不要把 <code>.passive</code>和<code>.prevent</code>一起使用,因为<code>.prevent</code>将会被忽略，同时浏览器可能会向你展示一个警告。<code>passive</code>会告诉浏览器你不想阻止事件的默认行为</p></blockquote></li><li>事件修饰符的小技巧<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 修饰符可以串联，阻止默认事件  --&gt;&lt;a v-on:click.stop.prevent&#x3D;&quot;toDo&quot;&gt;&lt;&#x2F;a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li></ul><h3 id="按键的修饰符"><a href="#按键的修饰符" class="headerlink" title="按键的修饰符"></a>按键的修饰符</h3><p>简介:通过键盘或鼠标的按键指定事件的触发方法(由于keyCode在Vue3.0废弃并且在一些高版本浏览器不支持,本文对keyCode形式的不作介绍)</p><ul><li>enter 回车键</li><li>tab</li><li>delete (捕获 “删除” 和 “退格” 键)</li><li>esc</li><li>space</li><li>up</li><li>down</li><li>left  (如果是鼠标就是左键)</li><li>right (如果是鼠标就是右键)</li><li>ctrl</li><li>alt</li><li>shift</li><li>meta  (MIT计算机键盘上的的一个特殊键)</li><li>middle(鼠标的中间滚轮键)</li></ul><blockquote><p>示例:<br>    <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 按下回车键触发search方法&lt;input type&#x3D;&quot;text&quot; v-on:keyup.enter&#x3D;&quot;search&quot; &#x2F;&gt;&#x2F;&#x2F; 按下鼠标中间滚轮键触发search方法&lt;button v-on:cilck.middle&#x3D;&quot;search&quot;&gt; 查找 &lt;&#x2F;button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></p></blockquote><h3 id="补充的修饰符"><a href="#补充的修饰符" class="headerlink" title="补充的修饰符"></a>补充的修饰符</h3><p>简介: 介绍了<code>.exact</code>修饰符和<code>.native</code>修饰符</p><ul><li>.exact修饰符<blockquote><p>作用: 精准的控制触发事件的按钮</p>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 只有按下enter键才可以触发search方法,如果同时按下 alt + enter 键,则不会触发&lt;input type&#x3D;&quot;text&quot; v-on:keyup.enter.exact&#x3D;&quot;search&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></blockquote></li><li>.native修饰符<blockquote><p>作用: 将原生事件绑定到组件,组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件</p>  <div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F;*     常用于一个纯icon组件,进行一个事件的绑定*&#x2F;&lt;template&gt;    &lt;comp @click.native&#x3D;&quot;consoleDetails&quot; &#x2F;&gt;&lt;&#x2F;template&gt;comp.vue    &lt;div&gt;        &lt;img src&#x3D;&quot;xxx&quot;&gt;    &lt;&#x2F;div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>值的注意: 在vue3.0中,将<code>.native</code>修饰符也进行了废弃,如果需要达到<code>.native</code>的修饰符的方法则不能将绑定在组件标签上的方法注册进<code>emits</code>选项中(或者<code>defineEmits([])</code>)</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue2</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo的基础搭建</title>
    <link href="/2021/11/18/hexo/hexoCreate/"/>
    <url>/2021/11/18/hexo/hexoCreate/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><ul><li>风一般的速度<br>Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 </li><li>流畅的撰写<br>支持GitHub Flavored Markdown和所有Octopress的插件。 </li><li>扩展性<br>Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less.</li></ul><h2 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h2><ul><li>所需环境<ul><li><a href="http://nodejs.cn/api/" title="Nodejsの中文镜像网站">Node.js</a></li><li><a href="https://git-scm.com/" title="git官网">git</a></li></ul></li><li>所需工具<ul><li><a href="https://github.com/" title="最大的同性交友网站">github</a></li><li><a href="https://hexo.io/zh-cn/" title="hexo中文官网">hexo</a></li></ul></li></ul><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket.png" />  <font size=5 face='微软雅黑' color="#1f87dd" style="font-weight:700;"> fist-step </font></div><ul class="nano-ul-flex">  <li>    <div >安装hexo脚手架</div>    <div class="nano-pointer">npm install -g hexo-cli</div>    <hr />  </li>   <li>    <div >初始化hexo文件夹</div>    <div class="nano-pointer">hexo init (初始化hexo)</div>    <div class="nano-pointer">npm install</div>    <hr />    <img src="/img/hexo-step1.png"/>    <div class="nano-tips"><span>Tips:</span> 如果出现报错,一般都是node版本过低导致,升级一下node版本就可以了(博主的node版本是v14.18.1)</div>    <hr />  </li>  <li>    <div >本地启动hexo</div>    <div class="nano-pointer">hexo g (生成hexo)</div>    <div class="nano-pointer">hexo s (启动本地服务器,这一步之后就可以通过http://localhost:4000 查看)</div>    <img src="/img/hexo-step2.png"/>    <div>&nbsp;</div>    <img src="/img/hexo-step3.png"/>    <div class="nano-success">    <img src="/img/success-new.png" />    这样就暂时先完成了本地博客的环境搭建啦~</div>    <div class="nano-tips"><span>Tips:</span> 如果出现端口占用问题可以输入      <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer">hexo s -p 41</font>      暂时切换端口    </div>    <hr />  </li></ul> <div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket.png">  <font size=5 face='微软雅黑' color="#1f87dd" style="font-weight:700;"> twice-step </font></div><ul class="nano-ul-flex">  <li>    <a href="https://github.com/">创建github账号</a>  </li>  <li>   <span>创建一个新的github仓库</span>   <img src="/img/github-create-1.png" />   <hr />   <img src="/img/github-create-2.png" />    <hr />    <img src="/img/github-create-3.png" />    <div class="nano-success">      <img src="/img/success-new.png" />    这样就完成了github的环境配置了~</div>  </li></ul><div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket.png" />  <font size=5 face='微软雅黑' color="#1f87dd" style="font-weight:700;"> third-step </font></div><ul class="nano-ul-flex">  <li>    <div >配置本地hexo部署到GitHub的文件</div>    <div>      编辑根目录下_config.yml文件,查找并切换到deploy字段位置,如图进行编辑:    </div>    <img src="/img/push-hexo1.png" />    <div class="nano-pd">      保存后安装扩展: <span class="nano-pointer">npm install hexo-deployer-git --save </span>      </div>    <div class="nano-tips"><span>Tips:</span> hexo的语法规定 <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> : </font>后面      <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer">必须有一个空格</font>    </div>    <hr />  </li>  <li>    <div >配置SSH Key 到GitHub</div>    <div>      <div>在Git Bash中输入: <span class="nano-pointer">ssh-keygen -t rsa -C "你的github邮箱号" </span> </div>      <div>之后按三下回车出现以下内容</div>      <img  src="/img/ssh-key-1.png" />    </div>    <hr />    <div>      <div>找到.ssh文件夹，并打开其中的id_rsa.pub文件，复制里面的内容</div>      <img  src="/img/ssh-key-2.png" />    </div>    <hr />    <div>      <div>之后按下面图片步骤执行</div>      <img  src="/img/ssh-key-3.png" />      <hr/>      <img  src="/img/ssh-key-4.png" />       <hr/>      <img  src="/img/ssh-key-5.png" />      <hr/>      <img  src="/img/ssh-key-6.png" />      <hr/>      <img  src="/img/ssh-key-7.png" />      <hr/>      <div>此时在git bush中输入 <span class="nano-pointer">ssh -T git@github.com<span></div>      <img  src="/img/ssh-key-8.png" />      <div class="nano-success">      <img src="/img/success-new.png" />    如果出现了以上语句,则说明设置成功~</div>    </div>    <hr />  </li>   <li>    <div >推送本地hexo 到GitHub</div>    <div>      <div>在Git Bash中设置用户信息:</div>      <img src="/img/hexo-to-push-1.png" />      <hr />      <div>编辑根目录下_config.yml文件,查找并切换到url字段位置,如图进行编辑:</div>      <img src="/img/hexo-to-push-2.png" />      <div class="nano-tips"><span>Tips:</span>  <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> 配置之后,初次上传就可以有样式了~ </font>      </div>      <hr />    </div>  </li></ul> <h2 id="搭建完成"><a href="#搭建完成" class="headerlink" title="搭建完成"></a>搭建完成</h2><div class="flex-start nano-flex-start-align-end ">   <img src="/img/rocket-succes.png" />  <font size=5 face='微软雅黑' color="red" style="font-weight:700;"> last-step </font></div><ul class="nano-ul-flex">  <li>    输入 <span class="nano-pointer">hexo d</span> 指令推送到远端    <img src="/img/hexo-to-push-5.png">    <div class="nano-tips"><span>Tips:</span>  <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> 网络原因可能会推送不成功,多试几下就好了~ </font>    </div>    <hr />  </li>   <li>    推送成功!    <img src="/img/hexo-to-push-3.png">    <hr />    <img src="/img/hexo-to-push-7.jpg">     <div class="nano-tips"><span>Tips:</span>  <font size=4 face='微软雅黑' color="#1f87dd" style="font-weight:700;" class="nano-pointer"> 因为picGo一直推不上去pc端的界面截图,所以展示了移动端的效果~ </font>    </div>     <hr />  </li>  <div class="nano-success">    <img src="/img/success-new.png" />    这样就完成了博客的搭建与上传~</div></ul> <h2 id="最后の一些话"><a href="#最后の一些话" class="headerlink" title="最后の一些话"></a>最后の一些话</h2><ul><li><p>附上一些其它常用指令 <br/></p><img src="/img/instruct-hexo.png" /></li><li><p>其它念叨 <br/></p><ul><li>之后也会陆续推出使用picgo搭配gitee做的图床教程,主要是为了减少静态资源的体积,本文的所有图片均来自gitee创建的图床~</li><li>一开始不用gitee而选择github的原因是因为gitee的pages服务需要人工审核,审了我蛮久的,github不需要审核,就是需要科学上网,所以gitee也是可以做博客的,有兴趣的同学可以自己尝试一下~</li><li>hexo还有主题这些,后面也会出一些教程,毕竟我也才开始弄hexo,也不是很会,可能只会写一些很浅显的东西- -</li><li>纪念第一篇博文,完结撒花,我去推了 2021-11-26</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
